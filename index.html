<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rogue-like F1 Deckbuilder ‚Äî Minimal Race Prototype</title>
  <style>
    :root {
      --bg:#0b0d10; --panel:#13161b; --panel-2:#1a1f26; --text:#e7eef7; --muted:#93a1b3;
      --accent:#69e2ff; --player:#ff6ad5; --ok:#7bd88f; --warn:#ffafcc; --bad:#ff6b6b;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font:14px/1.3 system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Noto Color Emoji, sans-serif; }
    .app { display:grid; grid-template-columns: minmax(0,30%) minmax(0,70%); gap:16px; height:100%; }
    header { grid-column:1 / -1; padding:10px 14px; background:var(--panel); border-bottom:1px solid #232a33; display:flex; align-items:center; gap:12px; position:sticky; top:0; z-index:2; }
    header h1 { font-size:16px; margin:0; font-weight:600; letter-spacing:0.2px; }
    header .spacer { flex:1; }
    button, select { background:var(--panel-2); color:var(--text); border:1px solid #2a3240; border-radius:8px; padding:6px 10px; cursor:pointer; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    select { font:inherit; }
    .wrap { padding:12px; }
    .board { background:var(--panel); border:1px solid #232a33; border-radius:12px; height:calc(100vh - 90px); position:relative; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .segment-info { position:absolute; top:16px; right:16px; background:var(--panel-2); border:1px solid #232a33; border-radius:12px; padding:10px 12px; min-width:160px; pointer-events:none; opacity:0; transition:opacity 0.15s ease; }
    .segment-info.visible { opacity:1; }
    .segment-info .segment-header { display:flex; align-items:center; gap:8px; margin-bottom:4px; }
    .segment-info .segment-range { display:block; margin-bottom:6px; }
    .segment-info .segment-meta { display:flex; flex-direction:column; gap:2px; }
    .side { display:flex; flex-direction:column; gap:12px; padding:12px; }
    .card { background:var(--panel); border:1px solid #232a33; border-radius:12px; padding:10px; }
    .standings table { width:100%; border-collapse:collapse; user-select:text; }
    .standings th, .standings td { padding:6px 4px; border-bottom:1px solid #222a33; text-align:left; }
    .standings td.tyre-cell, .standings th:nth-child(4) { text-align:center; }
    .in-pit { color:#69e2ff; font-weight:600; }
    .pit-time { color:#bd93f9; font-weight:600; }
    .tyre-badge { display:inline-flex; align-items:center; gap:4px; justify-content:center; }
    .tyre-ring { width:22px; height:22px; border-radius:50%; border:2px solid currentColor; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:600; }
    .standings td.speed-cell { width:120px; }
    .standings td.overtake-cell { text-align:center; font-variant-numeric:tabular-nums; }
    .standings tbody tr { cursor:pointer; }
    .standings tbody tr.focus { background:rgba(105, 226, 255, 0.12); }
    .standings tbody tr.focus td { color:var(--text); }
    .pos-change { font-size:11px; font-weight:600; margin-left:6px; }
    .pos-change.up { color:var(--ok); }
    .pos-change.down { color:var(--bad); }
    .speed-bar { position:relative; height:20px; border:1px solid #2a3240; border-radius:6px; background:#1a2028; overflow:visible; }
    .speed-bar .speed-fill { position:absolute; top:0; height:100%; border-radius:6px; pointer-events:none; }
    .speed-bar .speed-fill.base { left:0; background:linear-gradient(90deg, rgba(123,216,143,0.35), rgba(123,216,143,0.75)); }
    .speed-bar .speed-fill.boost { background:linear-gradient(90deg, rgba(255,210,0,0.4), rgba(255,210,0,0.85)); }
    .speed-bar .speed-fill.dirty { background:linear-gradient(90deg, rgba(220,60,60,0.4), rgba(220,60,60,0.85)); }
    .speed-bar span { position:relative; display:block; text-align:center; line-height:18px; font-size:12px; color:var(--text); z-index:2; }
    .speed-graph-wrapper { grid-column:1 / -1; padding:0 12px; }
    .speed-graph-surface { position:relative; height:240px; background:var(--panel); border:1px solid #232a33; border-radius:12px; overflow:hidden; }
    .speed-graph-surface canvas { width:100%; height:100%; display:block; }
    .speed-graph-label { position:absolute; top:10px; left:16px; text-transform:uppercase; letter-spacing:0.08em; font-size:11px; color:var(--muted); pointer-events:none; }
    .engagement-stats { display:flex; justify-content:center; gap:6px; font-size:12px; }
    .engagement-stats span { display:inline-block; }
    .engagement-stats .success { color:var(--ok); }
    .engagement-stats .fail { color:var(--bad); }
    .engagement-stats .sep { color:var(--muted); }
    .pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:12px; border:1px solid #2a3240; }
    .pill.straight { background:#0e3b2a; color:#b6ffd3; }
    .pill.corner  { background:#3b1a0e; color:#ffd2b6; }
    .pill.chicane { background:#26200e; color:#f2e6a0; }
    .tiny { color:var(--muted); font-size:12px; }
    .row { display:flex; gap:8px; align-items:center; }
    .flag { font-size:16px; margin-right:6px; display:inline-block; transform:translateY(1px); }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Race</h1>
      <div class="spacer"></div>
      <label class="tiny" for="sessionMode">Session:</label>
      <select id="sessionMode">
        <option value="practice" selected>Practice</option>
        <option value="race">Race</option>
      </select>
      <label class="tiny">Sim speed:</label>
      <select id="simSpeed">
        <option value="0.5">0.5√ó</option>
        <option value="1">1√ó</option>
        <option value="2">2√ó</option>
        <option value="5">5√ó</option>
        <option value="10" selected>10√ó</option>
        <option value="20">20√ó</option>
        <option value="50">50√ó</option>
      </select>
      <label class="tiny" for="lookaheadScale">Lookahead:</label>
      <input id="lookaheadScale" type="range" min="0.25" max="2" step="0.05" value="1" />
      <button id="btnStart">Start</button>
      <button id="btnPauseResume" disabled>Pause</button>
      <button id="btnRestart" disabled>Restart</button>
      <span id="status" class="tiny"></span>
    </header>

    <div class="speed-graph-wrapper">
      <div class="speed-graph-surface">
        <canvas id="speedGraph"></canvas>
        <div class="speed-graph-label tiny">Speed Trace (km/h)</div>
      </div>
    </div>

    <div class="wrap">
      <div class="board">
        <canvas id="track"></canvas>
        <div id="segmentInfo" class="segment-info">
          <div class="segment-header">
            <span id="segmentTag" class="pill straight">Straight</span>
            <span id="segmentIndex" class="tiny"></span>
          </div>
          <div id="segmentRange" class="segment-range tiny"></div>
          <div class="segment-meta tiny">
            <span id="segmentLength"></span>
            <span id="segmentGrip"></span>
          </div>
        </div>
      </div>
    </div>

    <aside class="side">
      <div class="card standings">
        <strong>Standings</strong>
        <table id="tbl">
          <thead><tr><th>#</th><th>Driver</th><th>Interval (s)</th><th>Tyre (%)</th><th>Engagements</th><th>Speed (km/h)</th><th>Lap (last / best)</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="card">
        <strong>Notes</strong>
        <p class="tiny">52 laps on a 2024-spec F1 grid. Live standings use the current championship form to set car pace. You replace Pierre Gasly in the <span style="color:#0090FF;font-weight:600">Alpine</span> and remain <span style="color:var(--player);font-weight:600">highlighted</span>.</p>
      </div>
    </aside>
  </div>

<script>
(() => {
  // ---- SIM CONFIG (metric) ----
  const TRACK_LENGTH_M = 5200;     // 5.2 km lap length
  const LAPS = 52;
  const TOTAL_LENGTH_M = TRACK_LENGTH_M * LAPS;
  // Approximate 2024 championship snapshot (post-Suzuka) to seed driver performance.
  const driverSeed = [
    { code:'YOU', name:'You (Alpine)', team:'BWT Alpine F1 Team', points:84, straight:0.52, corner:0.58, racecraft:0.55, defence:0.58, flag:'üèÅ', isPlayer:true },
    { code:'VER', name:'Max Verstappen', team:'Oracle Red Bull Racing', points:360, straight:1.00, corner:0.92, racecraft:0.98, defence:0.96, flag:'üá≥üá±', color:'#3671C6' },
    { code:'NOR', name:'Lando Norris', team:'McLaren F1 Team', points:291, straight:0.88, corner:0.94, racecraft:0.90, defence:0.89, flag:'üá¨üáß', color:'#FF8000' },
    { code:'LEC', name:'Charles Leclerc', team:'Scuderia Ferrari', points:273, straight:0.86, corner:0.96, racecraft:0.88, defence:0.90, flag:'üá≤üá®', color:'#F91536' },
    { code:'PIA', name:'Oscar Piastri', team:'McLaren F1 Team', points:246, straight:0.83, corner:0.90, racecraft:0.86, defence:0.84, flag:'üá¶üá∫', color:'#FF8000' },
    { code:'SAI', name:'Carlos Sainz', team:'Scuderia Ferrari', points:232, straight:0.84, corner:0.88, racecraft:0.87, defence:0.88, flag:'üá™üá∏', color:'#F91536' },
    { code:'RUS', name:'George Russell', team:'Mercedes-AMG Petronas', points:208, straight:0.80, corner:0.86, racecraft:0.84, defence:0.86, flag:'üá¨üáß', color:'#27F4D2' },
    { code:'HAM', name:'Lewis Hamilton', team:'Mercedes-AMG Petronas', points:196, straight:0.78, corner:0.89, racecraft:0.92, defence:0.93, flag:'üá¨üáß', color:'#27F4D2' },
    { code:'PER', name:'Sergio Perez', team:'Oracle Red Bull Racing', points:182, straight:0.82, corner:0.78, racecraft:0.80, defence:0.82, flag:'üá≤üáΩ', color:'#3671C6' },
    { code:'ALO', name:'Fernando Alonso', team:'Aston Martin Aramco', points:154, straight:0.74, corner:0.82, racecraft:0.88, defence:0.91, flag:'üá™üá∏', color:'#358C75' },
    { code:'STR', name:'Lance Stroll', team:'Aston Martin Aramco', points:96, straight:0.66, corner:0.70, racecraft:0.68, defence:0.72, flag:'üá®üá¶', color:'#358C75' },
    { code:'OCO', name:'Esteban Ocon', team:'BWT Alpine F1 Team', points:108, straight:0.68, corner:0.72, racecraft:0.74, defence:0.80, flag:'üá´üá∑', color:'#0090FF' },
    { code:'RIC', name:'Daniel Ricciardo', team:'RB F1 Team', points:72, straight:0.64, corner:0.69, racecraft:0.70, defence:0.76, flag:'üá¶üá∫', color:'#6692FF' },
    { code:'TSU', name:'Yuki Tsunoda', team:'RB F1 Team', points:88, straight:0.65, corner:0.76, racecraft:0.72, defence:0.78, flag:'üáØüáµ', color:'#6692FF' },
    { code:'ALB', name:'Alexander Albon', team:'Williams Racing', points:64, straight:0.67, corner:0.68, racecraft:0.71, defence:0.77, flag:'üáπüá≠', color:'#37BEDD' },
    { code:'SAR', name:'Logan Sargeant', team:'Williams Racing', points:22, straight:0.58, corner:0.60, racecraft:0.60, defence:0.65, flag:'üá∫üá∏', color:'#37BEDD' },
    { code:'HUL', name:'Nico H√ºlkenberg', team:'MoneyGram Haas F1', points:58, straight:0.63, corner:0.66, racecraft:0.69, defence:0.74, flag:'üá©üá™', color:'#B6BABD' },
    { code:'MAG', name:'Kevin Magnussen', team:'MoneyGram Haas F1', points:44, straight:0.62, corner:0.62, racecraft:0.65, defence:0.70, flag:'üá©üá∞', color:'#B6BABD' },
    { code:'BOT', name:'Valtteri Bottas', team:'Stake F1 Team Kick Sauber', points:38, straight:0.61, corner:0.64, racecraft:0.64, defence:0.73, flag:'üá´üáÆ', color:'#00FF87' },
    { code:'ZHO', name:'Zhou Guanyu', team:'Stake F1 Team Kick Sauber', points:28, straight:0.60, corner:0.63, racecraft:0.62, defence:0.69, flag:'üá®üá≥', color:'#00FF87' },
  ];
  const playerSeedIndex = driverSeed.findIndex(d => d.isPlayer);
  function driverIndexesForMode(mode) {
    if (mode === 'race') {
      return driverSeed.map((_, idx) => idx);
    }
    if (playerSeedIndex >= 0) return [playerSeedIndex];
    return [0];
  }
  function createDriversForMode(mode) {
    const indexes = driverIndexesForMode(mode);
    return indexes.map(idx => makeDriver(idx));
  }
  const TICK_RATE = 1/60;          // fixed-step integration
  const VIEW_PADDING_PX = 36;
  const GRID_SPACING_M = 10;
  const GRID_LANE_FACTOR = 0.6;
  const TYRE_DEGRADE_PER_M = 1/12000;
  const OVERTAKE_SUCCESS_EPS = 0.5;
  const OVERTAKE_GAP_THRESHOLD = 6;
  const OVERTAKE_SUCCESS_PENALTY = { strength: 0.12, duration: 1.2 };
  const OVERTAKE_FAIL_PENALTY = { strength: 0.10, duration: 1.0 };
  const tyreCompounds = {
    hard:   { wear: 1.0, grip: 1.0, accel: 1.0, life: 32 },
    medium: { wear: 1.5, grip: 1.05, accel: 1.05, life: 22 },
    soft:   { wear: 2.0, grip: 1.10, accel: 1.10, life: 14 }
  };
  const PIT_LANE_TIME = 25;
  const teamPitStats = {
    'Oracle Red Bull Racing':   { baseTime:3.1, agility:0.98, luck:0.2, lane:PIT_LANE_TIME },
    'McLaren F1 Team':          { baseTime:3.2, agility:0.95, luck:0.2, lane:PIT_LANE_TIME },
    'Scuderia Ferrari':         { baseTime:3.3, agility:0.93, luck:0.2, lane:PIT_LANE_TIME },
    'Mercedes-AMG Petronas':    { baseTime:3.4, agility:0.92, luck:0.2, lane:PIT_LANE_TIME },
    'Aston Martin Aramco':      { baseTime:3.5, agility:0.90, luck:0.2, lane:PIT_LANE_TIME },
    'BWT Alpine F1 Team':       { baseTime:3.6, agility:0.88, luck:0.2, lane:PIT_LANE_TIME },
    'RB F1 Team':               { baseTime:3.7, agility:0.86, luck:0.2, lane:PIT_LANE_TIME },
    'Williams Racing':          { baseTime:3.8, agility:0.85, luck:0.2, lane:PIT_LANE_TIME },
    'MoneyGram Haas F1':        { baseTime:3.9, agility:0.83, luck:0.2, lane:PIT_LANE_TIME },
    'Stake F1 Team Kick Sauber':{ baseTime:4.0, agility:0.82, luck:0.2, lane:PIT_LANE_TIME }
  };
  let fastestLapTime = Infinity;

  function choosePitCompound(driver, lapsRemaining) {
    const inventory = driver?.tyreInventory ?? [];
    const remaining = Math.max(0, Number.isFinite(lapsRemaining) ? lapsRemaining : 0);
    if (!inventory.length) {
      return driver?.carStats?.tyreCompound ?? 'hard';
    }
    const options = inventory.map(compound => ({
      compound,
      life: compoundLifeLaps(compound),
      speed: compoundSpeedRank(compound)
    }));
    const viableSingle = options
      .filter(opt => opt.life >= remaining)
      .sort((a, b) => (b.speed - a.speed) || (b.life - a.life));
    if (viableSingle.length) {
      return viableSingle[0].compound;
    }
    let bestCombo = null;
    for (let i = 0; i < options.length; i++) {
      const first = options[i];
      const remainingAfterFirst = Math.max(0, remaining - first.life);
      if (remainingAfterFirst <= 0) continue;
      for (let j = 0; j < options.length; j++) {
        if (i === j) continue;
        const second = options[j];
        if (second.life >= remainingAfterFirst) {
          const score = first.speed * 100 + second.speed * 10 + first.life;
          if (!bestCombo || score > bestCombo.score) {
            bestCombo = { first: first.compound, score };
          }
        }
      }
    }
    if (bestCombo) {
      return bestCombo.first;
    }
    options.sort((a, b) => (b.speed - a.speed) || (b.life - a.life));
    return options[0].compound;
  }

  const teamCarModifiers = {
    'McLaren F1 Team':         { top: 1.0, accel: 1.01, handling: 1.01 },
    'Oracle Red Bull Racing':  { top: 0.992, accel: 0.99, handling: 0.995 }
  };
  let lookaheadScale = 1;

  // Track segments: start/end in metres
  const trackBlueprint = [
    { type:'straight', length:240 },
    { type:'corner', length:160, direction:'right', speed:299 },
    { type:'corner', length:120, direction:'left', speed:298 },
    { type:'straight', length:180 },
    { type:'corner', length:140, direction:'right', speed:137 },
    { type:'straight', length:80 },
    { type:'corner', length:110, direction:'left', speed:90 },
    { type:'straight', length:90 },
    { type:'corner', length:150, direction:'left', speed:212 },
    { type:'straight', length:640, drs:true, drsId:'wellington' },
    { type:'corner', length:180, direction:'left', speed:181 },
    { type:'corner', length:220, direction:'right', speed:156 },
    { type:'straight', length:100 },
    { type:'corner', length:160, direction:'right', speed:272 },
    { type:'straight', length:320 },
    { type:'corner', length:200, direction:'right', speed:295 },
    { type:'straight', length:120 },
    { type:'corner', length:140, direction:'left', speed:303 },
    { type:'corner', length:130, direction:'right', speed:297 },
    { type:'corner', length:120, direction:'left', speed:289 },
    { type:'corner', length:130, direction:'right', speed:233 },
    { type:'corner', length:150, direction:'right', speed:172 },
    { type:'straight', length:750, drs:true, drsId:'hangar' },
    { type:'corner', length:220, direction:'right', speed:258 },
    { type:'straight', length:150 },
    { type:'corner', length:140, direction:'left', speed:121 },
    { type:'corner', length:220, direction:'right', speed:145 },
    { type:'straight', length:240 }
  ];
  function cornerDifficultyFromSpeed(speedKmh) {
    if (!Number.isFinite(speedKmh)) return 0.9;
    const norm = clamp(speedKmh / 330, 0, 1);
    return clamp(0.55 + (1 - norm) * 0.45, 0.55, 0.95);
  }
  function cornerGripFromSpeed(speedKmh) {
    if (!Number.isFinite(speedKmh)) return 0.65;
    const norm = clamp(speedKmh / 320, 0, 1);
    return clamp(0.58 + norm * 0.34, 0.58, 0.92);
  }
  const rawTrackLength = trackBlueprint.reduce((sum, piece) => sum + piece.length, 0);
  const trackScale = TRACK_LENGTH_M / rawTrackLength;
  let trackCursor = 0;
  const segments = trackBlueprint.map((piece, index) => {
    const remainingTrack = TRACK_LENGTH_M - trackCursor;
    const remainingSegments = trackBlueprint.length - index - 1;
    const minLength = 30;
    let segmentLength;
    if (index === trackBlueprint.length - 1) {
      segmentLength = remainingTrack;
    } else {
      const ideal = Math.round(piece.length * trackScale);
      const maxLength = Math.max(minLength, remainingTrack - remainingSegments * minLength);
      segmentLength = clamp(ideal, minLength, maxLength);
    }
    const start = trackCursor;
    const end = start + segmentLength;
    trackCursor = end;
    if (piece.type === 'corner') {
      const grip = cornerGripFromSpeed(piece.speed);
      const difficulty = cornerDifficultyFromSpeed(piece.speed);
      return seg('corner', start, end, grip, difficulty, false, null, piece.direction, piece.speed);
    }
    return seg(piece.type, start, end, 1.0, piece.difficulty, !!piece.drs, piece.drsId || null, piece.direction ?? null, piece.speed ?? null);
  });
  function seg(type, start, end, grip, overtakeDifficulty, drsZone=false, drsId=null, direction=null, refSpeed=null) {
    const baseGrip = (type === 'straight') ? 1.0 : (grip ?? 0.6);
    let difficulty = overtakeDifficulty;
    if (difficulty == null) {
      if (type === 'corner') difficulty = 0.9;
      else if (type === 'chicane') difficulty = 0.85;
      else difficulty = 1;
    }
    const cornerSpeedMs = (type === 'corner' && Number.isFinite(refSpeed)) ? refSpeed / 3.6 : null;
    return {
      type,
      start,
      end,
      grip: baseGrip,
      overtake: type === 'straight',
      difficulty,
      drs: !!drsZone,
      drsId: drsZone ? (drsId ?? `${start}-${end}`) : null,
      direction: direction ?? null,
      cornerSpeedKmh: refSpeed,
      cornerSpeedMs
    };
  }
  const cornerMarkers = segments
    .filter(seg => seg.type === 'corner')
    .map((seg, idx) => ({
      index: idx + 1,
      start: seg.start,
      apex: seg.start + (seg.end - seg.start) * 0.5,
      apexSpeed: seg.cornerSpeedMs ?? (Number.isFinite(seg.cornerSpeedKmh) ? seg.cornerSpeedKmh / 3.6 : null)
    }));
  const drsMarkers = segments
    .filter(seg => seg.drs)
    .map((seg, idx) => ({
      index: idx + 1,
      start: seg.start,
      label: `DRS ${idx + 1}`
    }));
  // ---- DRIVER MODEL ----
  const maxPoints = Math.max(...driverSeed.map(d => d.points));
  const MIN_FACTOR = 0.99;
  const MAX_FACTOR = 1.00;
  function balanceSkill(value, factor = 0.80) {
    const v = Number.isFinite(value) ? value : 0.5;
    return 0.5 + (v - 0.5) * factor;
  }
  function perfFactor(form){ return clamp(MIN_FACTOR + (MAX_FACTOR - MIN_FACTOR)*form, MIN_FACTOR, MAX_FACTOR); }
  function makeDriver(i) {
    const data = driverSeed[i];
    const isPlayer = !!data.isPlayer;
    const form = maxPoints > 0 ? clamp(data.points / maxPoints, 0, 1) : 0.5;
    const straightFocus = clamp(balanceSkill(data.straight ?? form), 0, 1);
    const cornerFocus = clamp(balanceSkill(data.corner ?? form), 0, 1);
    const racecraft = clamp(balanceSkill(data.racecraft ?? form), 0, 1);
    const driverFocus = clamp(balanceSkill(data.driver ?? form), 0, 1);
    const carTopFactor = perfFactor(lerp(form, straightFocus, 0.4));
    const carAccelFactor = perfFactor(lerp(form, racecraft, 0.3));
    const carHandlingFactor = perfFactor(lerp(form, cornerFocus, 0.5));
    const driverTopFactor = perfFactor(lerp(form, driverFocus, 0.5));
    const driverAccelFactor = perfFactor(lerp(form, racecraft, 0.4));
    const driverHandlingFactor = perfFactor(lerp(form, cornerFocus, 0.5));
    const driverBrakingFactor = perfFactor(lerp(form, cornerFocus, 0.6));
    const driverTyreFactor = lerp(0.9, 1, Math.random());
    const teamPit = teamPitStats[data.team] || { baseTime: 3.8, agility: 0.85, luck: 0.2, lane: PIT_LANE_TIME };
    const tyreInventory = createTyreInventory();
    const initialCompoundKey = drawTyreSet(tyreInventory) ?? 'medium';
    const compound = tyreCompounds[initialCompoundKey] || tyreCompounds.hard;
    const baseAccel = clamp01(carAccelFactor);
    const baseHandling = clamp01(carHandlingFactor);
    const baseWear = clamp01(lerp(0.2, 0.4, 1 - carHandlingFactor));
    const accelRateBase = 9 + 9 * clamp(baseAccel, 0, 1);
    const brakeRateBase = 26 + 12 * clamp(baseHandling, 0, 1);
    const carStats = {
      baseAccel,
      baseHandling,
      baseTyreDegradation: baseWear,
      accel: clamp01(baseAccel * (compound.accel ?? 1)),
      topSpeed: 360 * clamp(carTopFactor, MIN_FACTOR, MAX_FACTOR),
      handling: baseHandling,
      tyreCondition: 1,
      tyreDegradation: baseWear * (compound.wear ?? 1),
      tyreCompound: initialCompoundKey,
      tyreGripMult: compound.grip ?? 1,
      tyreWearMult: compound.wear ?? 1,
      maxAccelRate: accelRateBase,
      maxBrakeRate: brakeRateBase
    };
    applyCompoundToCar(carStats, initialCompoundKey);
    applyTeamModifiers(carStats, data.team);
    const defenceFocus = clamp(balanceSkill(data.defence ?? data.defense ?? racecraft), 0, 1);
    const driverRacecraft = clamp01(lerp(racecraft, form, 0.3));
    const driverDefense = clamp01(lerp(defenceFocus, form, 0.35));
    const anticipationSkill = clamp01(lerp(driverHandlingFactor, driverFocus, 0.5));
    const driverStats = {
      accel: clamp01(driverAccelFactor),
      topSpeed: clamp01(driverTopFactor),
      handling: clamp01(driverHandlingFactor),
      braking: clamp01(driverBrakingFactor),
      racecraft: driverRacecraft,
      defense: driverDefense,
      tyreManagement: driverTyreFactor,
      stress: 0
    };
    const baseLookaheadMin = isPlayer ? 0.005 : 0.02;
    const baseLookaheadInterval = clamp(lerp(0.03, 0.18, 1 - anticipationSkill), baseLookaheadMin, 0.22);
    const lookaheadScaleForDriver = isPlayer ? lookaheadScale : 1;
    const minLookaheadInterval = isPlayer ? 0.005 : 0.02;
    const lookaheadInterval = clamp(baseLookaheadInterval * lookaheadScaleForDriver, minLookaheadInterval, 0.35);
    return {
      id: i,
      code: data.code,
      name: data.name,
      team: data.team,
      flag: data.flag || 'üèÅ',
      color: isPlayer ? getCSS('--player') : (data.color ?? '#69e2ff'),
      teamColor: data.color ?? (isPlayer ? getCSS('--player') : '#69e2ff'),
      isPlayer,
      pos: 0,
      v: 0,
      finished: false,
      finishTime: null,
      lap: 0,
      carStats,
      driverStats,
      gridLane: 0,
      lapStartTime: 0,
      lastLapTime: null,
      bestLapTime: Infinity,
      lapTimes: [],
      laneSmooth: 0,
      laneTarget: 0,
      laneActual: 0,
      laneHold: false,
      pitJustExited: false,
      inPit: false,
      pitTimer: 0,
      pitStats: teamPit,
      pitLapDisplay: 0,
      pitTargetCompound: null,
      tyreInventory,
      tyreHistory: [initialCompoundKey],
      lastPitService: null,
      overtakePenalty: 0,
      overtakeTimer: 0,
      overtakeTotal: 0,
      overtakeSuccess: 0,
      overtakeFail: 0,
      segmentType: segments[0]?.type || 'straight',
      segmentIndex: 0,
      drsActiveSegment: null,
      drsZoneId: null,
      drsGranted: false,
      drsEntryGap: null,
      overtakePenaltySource: null,
      isDNF: false,
      overtakeBoostAccel: 0,
      overtakeBoostTop: 0,
      overtakeBoostTimer: 0,
      intervalDisplay: '‚Äî',
      throttle: 0,
      brake: 0,
      pedalPlan: null,
      missedApex: 0,
      baseLookaheadInterval,
      lookaheadInterval,
      lookaheadTimer: 0,
      targetThrottle: 1,
      targetBrakeIntent: 0,
      brakingForApex: false,
      activeApex: null,
      brakePrediction: null
    };
  }
  function currentSegment(x) {
    if (x < segments[0].start) return segments[0];
    for (const s of segments) if (x >= s.start && x < s.end) return s;
    return segments[segments.length - 1];
  }
  function segmentApexSpeed(seg) {
    if (!seg) return 0;
    if (Number.isFinite(seg.cornerSpeedMs)) return seg.cornerSpeedMs;
    if (Number.isFinite(seg.cornerSpeedKmh)) return seg.cornerSpeedKmh / 3.6;
    if (Number.isFinite(seg.speed)) return seg.speed / 3.6;
    return 90 / 3.6;
  }
  function segmentApexPosition(seg) {
    if (!seg) return 0;
    return seg.start + (seg.end - seg.start) * 0.5;
  }
  function nextCornerApexAfter(absPos) {
    const lapLength = TRACK_LENGTH_M;
    const currentLap = Math.floor(absPos / lapLength);
    for (let lapOffset = 0; lapOffset <= 1; lapOffset++) {
      const lapBase = (currentLap + lapOffset) * lapLength;
      for (const seg of segments) {
        if (seg.type !== 'corner' && seg.type !== 'chicane') continue;
        const apexLocal = segmentApexPosition(seg);
        const apexAbs = lapBase + apexLocal;
        if (apexAbs <= absPos + 1e-3) continue;
        return {
          seg,
          apexAbs,
          apexSpeed: segmentApexSpeed(seg),
          distance: apexAbs - absPos
        };
      }
    }
    return null;
  }
  function brakingDistance(currentSpeed, targetSpeed, decel) {
    if (!Number.isFinite(currentSpeed) || !Number.isFinite(targetSpeed)) return Infinity;
    if (!Number.isFinite(decel) || decel <= 0) return Infinity;
    const v0 = Math.max(0, currentSpeed);
    const vt = Math.max(0, targetSpeed);
    if (v0 <= vt) return 0;
    return Math.max(0, (v0 * v0 - vt * vt) / (2 * decel));
  }
  function approach(current, target, delta) {
    if (!Number.isFinite(current)) current = 0;
    if (!Number.isFinite(target)) target = 0;
    const step = Math.max(0, delta);
    if (current < target) return Math.min(target, current + step);
    if (current > target) return Math.max(target, current - step);
    return target;
  }
  function predictBrakingTrajectory({
    speed,
    targetSpeed,
    brakeRate,
    step = TICK_RATE,
    maxTime = 5,
    maxDistance = Infinity
  }) {
    const effectiveRate = Math.max(0, brakeRate || 0);
    if (!Number.isFinite(effectiveRate) || effectiveRate <= 0) {
      return { distance: Infinity, time: 0, finalSpeed: speed ?? 0, iterations: 0 };
    }
    const dt = Math.max(0.001, Math.min(0.05, Number.isFinite(step) ? step : TICK_RATE));
    const limitTime = Math.max(dt, Number.isFinite(maxTime) ? maxTime : 5);
    const limitDistance = Number.isFinite(maxDistance) ? Math.max(0, maxDistance) : Infinity;
    let v = Math.max(0, Number.isFinite(speed) ? speed : 0);
    const target = Math.max(0, Number.isFinite(targetSpeed) ? targetSpeed : 0);
    let distance = 0;
    let time = 0;
    let iterations = 0;
    while (v > target && time < limitTime && distance < limitDistance) {
      iterations++;
      const nextV = Math.max(0, v - effectiveRate * dt);
      const avgV = (v + nextV) * 0.5;
      distance += Math.max(0, avgV * dt);
      time += dt;
      v = nextV;
      if (iterations > 2000) break;
    }
    return { distance, time, finalSpeed: v, iterations };
  }
  function planPedalInputs(driver, context) {
    const { seg, apexInfo, brakeRate, dt } = context;
    const currentSpeed = Math.max(0, driver.v ?? 0);
    const minInterval = driver.isPlayer ? 0.005 : 0.02;
    const lookaheadInterval = clamp(driver.lookaheadInterval ?? 0.06, minInterval, 0.35);
    const LOOKAHEAD_METERS = 120;
    const BRAKE_RELEASE_FACTOR = 1.02;
    const EXIT_APEX_BUFFER = 8;
    const absPos = driver.pos ?? 0;
    let activeApex = driver.activeApex;
    const candidateApex = apexInfo;
    if (activeApex && candidateApex && candidateApex.seg === activeApex.seg) {
      activeApex = candidateApex;
    }
    if (activeApex) {
      const distanceToActive = activeApex.apexAbs - absPos;
      if (distanceToActive <= -EXIT_APEX_BUFFER && !driver.brakingForApex) {
        activeApex = null;
      }
    }
    if (!activeApex && candidateApex) {
      activeApex = candidateApex;
    }
    let apexTarget = null;
    if (activeApex) {
      const distance = activeApex.apexAbs - absPos;
      apexTarget = {
        seg: activeApex.seg,
        apexAbs: activeApex.apexAbs,
        apexSpeed: activeApex.apexSpeed,
        distance
      };
    }
    driver.activeApex = activeApex;
    driver.lookaheadTimer = Math.max(0, (driver.lookaheadTimer ?? 0) - dt);
    if (driver.lookaheadTimer <= 0) {
      driver.lookaheadTimer = lookaheadInterval;
      let throttleTarget = 1;
      let brakeIntent = 0;
      let brakePrediction = null;
      if (apexTarget) {
        const apexSpeed = apexTarget.apexSpeed;
        const horizon = LOOKAHEAD_METERS;
        const distToApex = apexTarget.distance;
        let shouldBrake = false;
        if (brakeRate > 0 && distToApex <= horizon) {
          brakePrediction = predictBrakingTrajectory({
            speed: currentSpeed,
            targetSpeed: apexSpeed,
            brakeRate,
            step: Math.min(dt, TICK_RATE),
            maxTime: 6,
            maxDistance: distToApex + 10
          });
          const predictedDistance = brakePrediction?.distance ?? Infinity;
          if (predictedDistance > Math.max(0, distToApex - 1.5)) {
            shouldBrake = true;
          }
        }
        const currentlyBraking = !!driver.brakingForApex;
        if (currentlyBraking) {
          if (distToApex <= 0 || currentSpeed <= apexSpeed * BRAKE_RELEASE_FACTOR) {
            driver.brakingForApex = false;
          }
        } else if (shouldBrake) {
          driver.brakingForApex = true;
        }
        if (driver.brakingForApex) {
          brakeIntent = 1;
          throttleTarget = 0;
        }
      }
      driver.targetThrottle = throttleTarget;
      driver.targetBrakeIntent = brakeIntent;
      driver.brakePrediction = brakePrediction;
    }
    const throttleGoal = clamp(driver.targetThrottle ?? 1, 0, 1);
    const brakeGoal = clamp(driver.targetBrakeIntent ?? 0, 0, 1);
    driver.throttle = throttleGoal;
    driver.brake = brakeGoal;
    driver.pedalPlan = apexTarget;
    return {
      throttle: driver.throttle,
      brake: driver.brake
    };
  }

  // ---- DOM & RENDER ----
  const canvas = document.getElementById('track');
  const ctx = canvas.getContext('2d');
  const tbl = document.querySelector('#tbl tbody');
  const statusEl = document.getElementById('status');
  const segmentInfo = document.getElementById('segmentInfo');
  const segmentTag = document.getElementById('segmentTag');
  const segmentIndexEl = document.getElementById('segmentIndex');
  const segmentRangeEl = document.getElementById('segmentRange');
  const segmentLengthEl = document.getElementById('segmentLength');
  const segmentGripEl = document.getElementById('segmentGrip');
  const speedGraphSurface = document.querySelector('.speed-graph-surface');
  const speedGraphCanvas = document.getElementById('speedGraph');
  const speedGraphCtx = speedGraphCanvas ? speedGraphCanvas.getContext('2d') : null;
  const lookaheadScaleInput = document.getElementById('lookaheadScale');
  const speedGraphState = {
    points: [],
    prevPoints: [],
    lastDriverId: null,
    lastLap: null,
    lastLapPos: 0,
    dpr: 1,
  };
  const SPEED_GRAPH_MIN_STEP = 0.0006;
  const SPEED_GRAPH_MAX_POINTS = 4000;
  let speedGraphReady = false;
  const sessionModeSel = document.getElementById('sessionMode');
  let sessionMode = sessionModeSel?.value || 'practice';
  const simSpeedSel = document.getElementById('simSpeed');
  let simSpeed = simSpeedSel ? parseFloat(simSpeedSel.value) : 1;
  simSpeedSel.addEventListener('change',()=>{ simSpeed = parseFloat(simSpeedSel.value); });
  if (lookaheadScaleInput) {
    const initialScale = parseFloat(lookaheadScaleInput.value);
    if (Number.isFinite(initialScale)) {
      lookaheadScale = initialScale;
      lookaheadScaleInput.title = `${initialScale.toFixed(2)}√ó`;
    }
  }
  sessionModeSel?.addEventListener('change', () => {
    setSessionMode(sessionModeSel.value);
  });
  let isHoveringSegment = false;
  let segmentState = { source:'', index:-1, lap:null };
  canvas.addEventListener('pointermove', handleSegmentPointer);
  canvas.addEventListener('pointerleave', handleSegmentLeave);
  tbl.addEventListener('click', (evt) => {
    const baseTarget = evt.target && evt.target.nodeType === Node.ELEMENT_NODE
      ? evt.target
      : evt.target?.parentElement;
    if (!baseTarget) return;
    const row = baseTarget.closest('tr[data-driver]');
    if (!row) return;
    const id = Number(row.dataset.driver);
    if (!Number.isFinite(id)) return;
    if (cameraState.targetId !== id) {
      cameraState.targetId = id;
      isHoveringSegment = false;
      updateSegmentInfoForPlayer();
      updateStatus();
    }
  });

  function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
  }
  window.addEventListener('resize', resize);
  resize();

  const cameraState = {
    pos: 0,
    lapIndex: 0,
    lapPos: 0,
    scale: 1,
    pad: 0,
    height: 0,
    centerY: 0,
    dpr: 1,
    targetId: 0,
  };

  function getFocusDriver() {
    return drivers.find(d => d.id === cameraState.targetId) || drivers[0] || null;
  }

  function resizeSpeedGraph() {
    if (!speedGraphCanvas || !speedGraphSurface) return;
    const rect = speedGraphSurface.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    speedGraphState.dpr = dpr;
    const targetWidth = Math.floor(rect.width * dpr);
    const targetHeight = Math.floor(rect.height * dpr);
    const changed = speedGraphCanvas.width !== targetWidth || speedGraphCanvas.height !== targetHeight;
    speedGraphCanvas.width = targetWidth;
    speedGraphCanvas.height = targetHeight;
    speedGraphCanvas.style.width = rect.width + 'px';
    speedGraphCanvas.style.height = rect.height + 'px';
    return changed;
  }
  window.addEventListener('resize', () => {
    if (resizeSpeedGraph() && speedGraphReady) {
      renderSpeedGraph();
    }
  });
  resizeSpeedGraph();

  function resetSpeedGraph(driver = null) {
    speedGraphState.points = [];
    speedGraphState.prevPoints = [];
    speedGraphState.lastDriverId = driver?.id ?? null;
    if (driver) {
      const basePos = driver.pos ?? 0;
      const lapNumber = Number.isFinite(driver.lap) ? driver.lap : Math.floor(basePos / TRACK_LENGTH_M);
      const lapPos = driver.finished ? TRACK_LENGTH_M - 1e-3 : ((basePos % TRACK_LENGTH_M) + TRACK_LENGTH_M) % TRACK_LENGTH_M;
      speedGraphState.lastLap = lapNumber;
      speedGraphState.lastLapPos = lapPos;
    } else {
      speedGraphState.lastLap = null;
      speedGraphState.lastLapPos = 0;
    }
  }

  function sampleSpeedGraph(driver = null, options = {}) {
    if (!speedGraphCanvas || !speedGraphCtx) return;
    const focus = driver || getFocusDriver();
    if (!focus) return;
    const { force = false } = options;
    const basePos = focus.pos ?? 0;
    const lapPos = focus.finished ? TRACK_LENGTH_M - 1e-3 : ((basePos % TRACK_LENGTH_M) + TRACK_LENGTH_M) % TRACK_LENGTH_M;
    const lapNumber = Number.isFinite(focus.lap) ? focus.lap : Math.floor(basePos / TRACK_LENGTH_M);
    if (speedGraphState.lastDriverId !== focus.id) {
      resetSpeedGraph(focus);
    }
    if (speedGraphState.lastLap != null && lapNumber > speedGraphState.lastLap) {
      if (speedGraphState.points.length > 1) {
        const prevPoint = speedGraphState.points[speedGraphState.points.length - 1];
        if (prevPoint && prevPoint.x < 0.999) {
          speedGraphState.points.push({
            x: 1,
            speed: prevPoint.speed,
            throttle: prevPoint.throttle ?? 0,
            brake: prevPoint.brake ?? 0
          });
        }
        speedGraphState.prevPoints = speedGraphState.points.slice(-SPEED_GRAPH_MAX_POINTS);
      } else {
        speedGraphState.prevPoints = [];
      }
      speedGraphState.points = [];
    }
    const progress = TRACK_LENGTH_M > 0 ? lapPos / TRACK_LENGTH_M : 0;
    const speedKmh = Math.max(0, (focus.v ?? 0) * 3.6);
    const lastPoint = speedGraphState.points[speedGraphState.points.length - 1];
    const throttleVal = clamp01(focus.throttle ?? 0);
    const brakeVal = clamp01(focus.brake ?? 0);
    if (!lastPoint) {
      speedGraphState.points.push({ x: progress, speed: speedKmh, throttle: throttleVal, brake: brakeVal });
    } else {
      const delta = progress - lastPoint.x;
      if (force || delta >= SPEED_GRAPH_MIN_STEP) {
        speedGraphState.points.push({ x: progress, speed: speedKmh, throttle: throttleVal, brake: brakeVal });
      } else if (Math.abs(delta) <= SPEED_GRAPH_MIN_STEP * 0.5) {
        lastPoint.speed = speedKmh;
        lastPoint.throttle = throttleVal;
        lastPoint.brake = brakeVal;
      }
    }
    speedGraphState.lastDriverId = focus.id;
    speedGraphState.lastLap = lapNumber;
    speedGraphState.lastLapPos = lapPos;
    if (speedGraphState.points.length > SPEED_GRAPH_MAX_POINTS) {
      speedGraphState.points.splice(0, speedGraphState.points.length - SPEED_GRAPH_MAX_POINTS);
    }
  }

  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function compoundSpeedRank(key) {
    switch (key) {
      case 'soft': return 3;
      case 'medium': return 2;
      case 'hard': return 1;
      default: return 0;
    }
  }

  function compoundLifeLaps(key) {
    return tyreCompounds[key]?.life ?? 18;
  }

  function createTyreInventory() {
    const sets = [];
    let softUsed = false;
    while (sets.length < 3) {
      const choices = softUsed ? ['hard', 'medium'] : ['hard', 'medium', 'soft'];
      const choice = choices[Math.floor(Math.random() * choices.length)];
      if (choice === 'soft') softUsed = true;
      sets.push(choice);
    }
    return sets;
  }

  function drawTyreSet(inventory, preferred = null) {
    if (!inventory || inventory.length === 0) return null;
    if (preferred) {
      const idx = inventory.indexOf(preferred);
      if (idx !== -1) {
        const [compound] = inventory.splice(idx, 1);
        return compound;
      }
    }
    const idx = Math.floor(Math.random() * inventory.length);
    const [compound] = inventory.splice(idx, 1);
    return compound;
  }

  function applyGridPositions(list) {
    const total = list.length;
    const makeSlots = (start, end) => {
      const bucket = [];
      const cappedStart = Math.min(start, total);
      const cappedEnd = Math.min(end, total);
      if (cappedStart >= cappedEnd) return bucket;
      for (let slot = cappedStart; slot < cappedEnd; slot++) bucket.push(slot);
      return shuffleArray(bucket);
    };
    const groupSlots = [
      makeSlots(0, 5),
      makeSlots(5, 10),
      makeSlots(10, 20)
    ];
    const playerIndex = list.findIndex(d => d.isPlayer);
    const player = playerIndex >= 0 ? list[playerIndex] : null;
    const others = player ? list.filter(d => d.id !== player.id) : [...list];
    const groupDrivers = [[], [], []];
    const group0Count = Math.min(5, others.length);
    const group1Count = Math.min(5, Math.max(0, others.length - group0Count));
    groupDrivers[0] = others.slice(0, group0Count);
    groupDrivers[1] = others.slice(group0Count, group0Count + group1Count);
    groupDrivers[2] = others.slice(group0Count + group1Count);
    if (player) groupDrivers[2].push(player);
    const slotFor = new Map();
    groupDrivers.forEach((driversInGroup, groupIndex) => {
      const slots = groupSlots[groupIndex] ?? [];
      for (const drv of driversInGroup) {
        const slot = slots.length ? slots.shift() : null;
        if (slot != null) slotFor.set(drv.id, slot);
      }
    });
    const remainingSlots = [];
    const usedSlots = new Set(slotFor.values());
    for (let slot = 0; slot < total; slot++) {
      if (!usedSlots.has(slot)) remainingSlots.push(slot);
    }
    const lastSlot = total > 0 ? total - 1 : 0;
    for (let i = 0; i < total; i++) {
      const d = list[i];
      let slot = slotFor.get(d.id);
      if (slot == null) {
        slot = remainingSlots.length ? remainingSlots.shift() : i;
      }
      const isSoloLastRow = (total % 2 === 1) && slot === lastSlot && slot % 2 === 0;
      const lane = isSoloLastRow ? 0 : (slot % 2 === 0 ? -1 : 1);
      d.startSlot = slot;
      d.pos = -slot * GRID_SPACING_M;
      d.v = 0;
      d.finished = false;
      d.finishTime = null;
      d.lap = 0;
      d.gridLane = lane;
      d.laneTarget = lane;
      d.laneActual = lane;
      d.laneSmooth = 0;
      d.laneHold = false;
      d.lapStartTime = 0;
      d.lastLapTime = null;
      d.bestLapTime = Infinity;
      d.lapTimes = [];
      d.throttle = 0;
      d.brake = 0;
      d.pedalPlan = null;
      d.activeApex = null;
      d.missedApex = 0;
      d.lookaheadTimer = 0;
      d.targetThrottle = 1;
      d.targetBrakeIntent = 0;
      d.brakingForApex = false;
      d.brakePrediction = null;
    }
  }

  function drawTrack(drivers) {
    const w = canvas.width, h = canvas.height;
    const dpr = window.devicePixelRatio || 1;
    const pad = VIEW_PADDING_PX * dpr;
    ctx.clearRect(0,0,w,h);

    const focus = drivers.find(d => d.id === cameraState.targetId) || drivers[0];
    const playerPos = focus ? focus.pos : 0;
    const playerLapIndex = focus ? (focus.lap ?? Math.floor(focus.pos / TRACK_LENGTH_M)) : 0;
    const playerLapPos = focus ? ((focus.pos % TRACK_LENGTH_M) + TRACK_LENGTH_M) % TRACK_LENGTH_M : 0;
    const span = Math.max(1, h - pad * 2);
    const viewWindow = Math.max(1, TRACK_LENGTH_M * 0.1);
    const scale = span / viewWindow;
    cameraState.pos = playerPos;
    cameraState.lapIndex = playerLapIndex;
    cameraState.lapPos = playerLapPos;
    cameraState.scale = scale;
    cameraState.pad = pad;
    cameraState.height = h;
    cameraState.centerY = h * 0.5;
    cameraState.dpr = dpr;

    const trackWidth = 200 * dpr;
    const trackHalf = trackWidth * 0.5;
    const laneWidth = 20 * dpr;
    const laneSpacing = trackWidth * 1.4;
    let trackX = Math.max(pad + trackHalf, Math.floor(w * 0.35));
    let laneCenter = trackX + laneSpacing;
    let laneRight = laneCenter + laneWidth * 0.5;
    if (laneRight + pad > w) {
      const shift = (laneRight + pad) - w;
      trackX = Math.max(pad + trackHalf, trackX - shift);
      laneCenter = trackX + laneSpacing;
      laneRight = laneCenter + laneWidth * 0.5;
      if (laneRight + pad > w) {
        laneCenter = Math.min(w - pad - laneWidth * 0.5, laneCenter);
        laneRight = laneCenter + laneWidth * 0.5;
      }
    }
    const laneLeft = laneCenter - laneWidth * 0.5;
    const laneHeight = h - pad * 2;

    const laneOffset = trackHalf * GRID_LANE_FACTOR;
    const lateralOffsets = computeLateralOffsets(drivers, trackHalf, laneOffset);

    // start/finish
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#ffffff';
    for (let offset = -1; offset <= 1; offset++) {
      const startAbs = (playerLapIndex + offset) * TRACK_LENGTH_M;
      const finishAbs = (playerLapIndex + offset + 1) * TRACK_LENGTH_M;
      const startY = absPosToScreenY(startAbs);
      const finishY = absPosToScreenY(finishAbs);
      ctx.beginPath();
      if (startY >= pad && startY <= h - pad) {
        ctx.moveTo(trackX - trackHalf, startY);
        ctx.lineTo(trackX + trackHalf, startY);
      }
      if (finishY >= pad && finishY <= h - pad) {
        ctx.moveTo(trackX - trackHalf, finishY);
        ctx.lineTo(trackX + trackHalf, finishY);
      }
      ctx.stroke();
    }

    // segments (tile +/- one lap)
    for (let offset = -1; offset <= 1; offset++) {
      for (const s of segments) {
        if (s.type === 'straight' && !s.drs) continue;
        const startAbs = (playerLapIndex + offset) * TRACK_LENGTH_M + s.start;
        const endAbs = (playerLapIndex + offset) * TRACK_LENGTH_M + s.end;
        let y1 = absPosToScreenY(startAbs);
        let y2 = absPosToScreenY(endAbs);
        const clampedStart = clamp(y1, pad, h - pad);
        const clampedEnd = clamp(y2, pad, h - pad);
        if (clampedStart === clampedEnd) continue;
        const segTop = Math.min(clampedStart, clampedEnd);
        const segHeight = Math.abs(clampedEnd - clampedStart);
        if (s.drs && s.type === 'straight') {
          ctx.fillStyle = 'rgba(105, 196, 255, 0.05)';
          ctx.fillRect(trackX - trackHalf, segTop, trackWidth, segHeight);
          ctx.fillStyle = '#69c4ff';
          ctx.font = `bold ${12 * dpr}px system-ui`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('DRS', trackX, segTop + segHeight * 0.5);
        } else {
          ctx.fillStyle = segColor(s.type, 0.35);
          ctx.fillRect(trackX - trackHalf, segTop, trackWidth, segHeight);
          ctx.fillStyle = segColor(s.type, 1);
          ctx.font = `bold ${12 * dpr}px system-ui`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(segLabel(s), trackX, segTop + segHeight * 0.5);
        }
      }
    }

    // track border
    ctx.save();
    ctx.lineWidth = 2 * dpr;
    ctx.strokeStyle = 'rgba(147, 161, 179, 0.45)';
    ctx.beginPath();
    ctx.moveTo(trackX - trackHalf, pad);
    ctx.lineTo(trackX - trackHalf, h - pad);
    ctx.moveTo(trackX + trackHalf, pad);
    ctx.lineTo(trackX + trackHalf, h - pad);
    ctx.stroke();
    ctx.restore();

    // lap progress lane
    ctx.fillStyle = 'rgba(34, 41, 50, 0.9)';
    ctx.fillRect(laneLeft, pad, laneWidth, laneHeight);
    ctx.strokeStyle = 'rgba(147, 161, 179, 0.35)';
    ctx.lineWidth = 1.5 * dpr;
    ctx.strokeRect(laneLeft, pad, laneWidth, laneHeight);
    ctx.lineWidth = 1 * dpr;
    for (let lap = 0; lap < LAPS; lap++) {
      const lapStart = lap * TRACK_LENGTH_M;
      const lapEnd = (lap + 1) * TRACK_LENGTH_M;
      const yTop = mapTotalProgressToY(lapStart, h, pad);
      const yBottom = mapTotalProgressToY(lapEnd, h, pad);
      const y1 = Math.min(yTop, yBottom);
      const y2 = Math.max(yTop, yBottom);
      ctx.fillStyle = lap % 2 ? 'rgba(105, 226, 255, 0.08)' : 'rgba(123, 216, 143, 0.08)';
      ctx.fillRect(laneLeft, y1, laneWidth, y2 - y1);
      ctx.strokeStyle = 'rgba(147, 161, 179, 0.25)';
      ctx.beginPath();
      ctx.moveTo(laneLeft, y2);
      ctx.lineTo(laneLeft + laneWidth, y2);
      ctx.stroke();
    }

    // drivers
    const laneJitter = laneWidth * 0.45;
    let focusPoint = null;
    for (let i=0;i<drivers.length;i++) {
      const d = drivers[i];
      const isFocus = focus && d.id === focus.id;
      const lateralOffset = lateralOffsets.get(d.id) ?? 0;
      const xi = clamp(trackX + lateralOffset, trackX - trackHalf + 6 * dpr, trackX + trackHalf - 6 * dpr);
      const yRaw = absPosToScreenY(d.pos);
      const yClamped = clamp(yRaw, pad, h - pad);
      const offscreen = yRaw < pad || yRaw > h - pad;
      ctx.beginPath();
      ctx.fillStyle = d.color;
      ctx.globalAlpha = offscreen && !isFocus ? 0.45 : 1;
      ctx.arc(xi, yClamped, 6 * dpr, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      const totalPos = d.finished ? TOTAL_LENGTH_M : clamp(d.pos, 0, TOTAL_LENGTH_M);
      const laneY = mapTotalProgressToY(totalPos, h, pad);
      const laneNoise = isFocus ? 0 : (((i*6131) % 100)/100 - 0.5);
      const laneXi = laneCenter + laneNoise * laneJitter;
      ctx.beginPath();
      ctx.fillStyle = d.color;
      ctx.arc(laneXi, laneY, 4.5 * dpr, 0, Math.PI*2);
      ctx.fill();
      if (isFocus) {
        focusPoint = { x: xi, y: yClamped };
      }
    }

    if (focus && focusPoint) {
      const bubbleColor = focus.color || getCSS('--accent') || '#69e2ff';
      const label = focus.isPlayer ? 'You' : focus.name;
      drawPlayerCallout(focusPoint.x, focusPoint.y, bubbleColor, label);
    }

    ctx.fillStyle = '#b3c1d1';
    ctx.font = `${12 * dpr}px system-ui`;
    ctx.textAlign = 'left';
    const startY = absPosToScreenY(playerLapIndex * TRACK_LENGTH_M);
    if (startY >= pad && startY <= h - pad) ctx.fillText('START', trackX + trackHalf + 12, startY);
    const finishY = absPosToScreenY((playerLapIndex + 1) * TRACK_LENGTH_M);
    if (finishY >= pad && finishY <= h - pad) ctx.fillText('FINISH', trackX + trackHalf + 12, finishY);

    function computeLateralOffsets(list, halfWidth, laneOffset) {
      const result = new Map();
      const sorted = [...list].sort((a,b)=>b.pos - a.pos);
      if (!started || finished) {
        for (const d of sorted) {
          const lane = clamp(d.gridLane ?? 0, -1, 1);
          d.laneTarget = lane;
          d.laneHold = false;
        }
      } else {
        const closeSet = new Set();
        for (const d of sorted) {
          if (!d.laneHold) d.laneTarget = 0;
        }
        for (let idx=1; idx<sorted.length; idx++) {
          const ahead = sorted[idx-1];
          const behind = sorted[idx];
          const gap = ahead.pos - behind.pos;
          if (gap < 5) {
            closeSet.add(ahead.id);
            closeSet.add(behind.id);
            const attack = clamp01(behind.driverStats?.racecraft ?? 0.5);
            const defence = clamp01(ahead.driverStats?.defense ?? 0.5);
            if ((behind.v - ahead.v) > 0.3 && (attack + 0.05 > defence || gap < 2.5)) {
              const dir = (behind.gridLane !== 0 ? Math.sign(behind.gridLane) : (behind.id % 2 ? 1 : -1));
              behind.laneTarget = dir;
              behind.laneHold = true;
            } else if ((ahead.v - behind.v) > 0.3 && gap < 4 && (defence + 0.05 >= attack)) {
              const dir = (ahead.gridLane !== 0 ? Math.sign(ahead.gridLane) : (ahead.id % 2 ? -1 : 1));
              ahead.laneTarget = dir;
              ahead.laneHold = true;
            } else {
              if (behind.laneHold || Math.abs(behind.laneActual) > 0.15) {
                behind.laneTarget = Math.sign(behind.laneActual || (behind.gridLane ?? 0));
                behind.laneHold = true;
              }
              if (ahead.laneHold || Math.abs(ahead.laneActual) > 0.15) {
                ahead.laneTarget = Math.sign(ahead.laneActual || (ahead.gridLane ?? 0));
                ahead.laneHold = true;
              }
              if (defence > attack && gap < 3) {
                ahead.laneHold = true;
              }
            }
          }
        }
        for (const d of sorted) {
          if (!closeSet.has(d.id)) {
            d.laneHold = false;
            if (Math.abs(d.laneTarget) > 0 && Math.abs(d.laneActual) < 0.05) {
              d.laneTarget = 0;
            }
          }
        }
      }
      for (const d of sorted) {
        const speed = Math.abs(d.v);
        const base = started ? 0.008 : 0.08;
        const speedFactor = clamp(speed / 45, 0, 1);
        d.laneSmooth = lerp(base, started ? 0.10 : 0.22, speedFactor);
      }
      for (const d of sorted) {
        const prevTarget = (d.laneTarget !== undefined ? d.laneTarget : (d.gridLane ?? 0));
        const holdFallback = Math.abs(d.laneActual) > 0.01 ? Math.sign(d.laneActual) : prevTarget;
        const target = clamp(d.laneHold ? (Math.abs(d.laneTarget ?? 0) > 0 ? d.laneTarget : holdFallback) : (d.laneTarget ?? 0), -1, 1);
        if (!Number.isFinite(d.laneActual)) d.laneActual = target;
        const smoothStep = d.laneSmooth ?? (started ? 0.07 : 0.24);
        d.laneActual += (target - d.laneActual) * smoothStep;
        result.set(d.id, clamp(d.laneActual, -1.3, 1.3) * laneOffset);
      }
      return result;
    }
  }

  function drawPlayerCallout(px, py, playerColor, label = 'You') {
    const dpr = window.devicePixelRatio || 1;
    const paddingX = 14 * dpr;
    const paddingY = 8 * dpr;
    const pointerHalf = 8 * dpr;
    const tipOffset = 9 * dpr;
    const radius = 10 * dpr;
    const margin = 16 * dpr;

    ctx.save();
    ctx.font = `600 ${12 * dpr}px system-ui`;
    const textMetrics = ctx.measureText(label);
    const bubbleW = Math.max(80 * dpr, textMetrics.width + paddingX * 2);
    const bubbleH = Math.max(32 * dpr, 12 * dpr + paddingY * 2);

    let bx = px + 24 * dpr;
    let bubbleOnLeft = false;
    if (bx + bubbleW + margin > canvas.width) {
      bx = px - 24 * dpr - bubbleW;
      bubbleOnLeft = true;
    }
    if (bx < margin) {
      bx = margin;
      bubbleOnLeft = bx + bubbleW < px;
    }
    let by = py - bubbleH / 2;
    if (by < margin) by = margin;
    if (by + bubbleH + margin > canvas.height) by = canvas.height - bubbleH - margin;

    const pointerBaseY = Math.max(by + radius, Math.min(by + bubbleH - radius, py));
    const baseMin = by + 4 * dpr;
    const baseMax = by + bubbleH - 4 * dpr;
    let baseTop = pointerBaseY - pointerHalf;
    let baseBottom = pointerBaseY + pointerHalf;
    if (baseTop < baseMin) {
      baseTop = baseMin;
      baseBottom = Math.min(baseMax, baseTop + pointerHalf * 2);
    }
    if (baseBottom > baseMax) {
      baseBottom = baseMax;
      baseTop = Math.max(baseMin, baseBottom - pointerHalf * 2);
    }

    const baseX = bubbleOnLeft ? bx + bubbleW : bx;
    const tipX = bubbleOnLeft ? px - tipOffset : px + tipOffset;

    ctx.lineWidth = 2 * dpr;
    ctx.fillStyle = 'rgba(255, 209, 102, 0.18)';
    ctx.strokeStyle = playerColor;

    ctx.beginPath();
    ctx.moveTo(bx + radius, by);
    ctx.lineTo(bx + bubbleW - radius, by);
    ctx.quadraticCurveTo(bx + bubbleW, by, bx + bubbleW, by + radius);
    ctx.lineTo(bx + bubbleW, by + bubbleH - radius);
    ctx.quadraticCurveTo(bx + bubbleW, by + bubbleH, bx + bubbleW - radius, by + bubbleH);
    ctx.lineTo(bx + radius, by + bubbleH);
    ctx.quadraticCurveTo(bx, by + bubbleH, bx, by + bubbleH - radius);
    ctx.lineTo(bx, by + radius);
    ctx.quadraticCurveTo(bx, by, bx + radius, by);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(tipX, py);
    ctx.lineTo(baseX, baseTop);
    ctx.lineTo(baseX, baseBottom);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = playerColor;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, bx + bubbleW / 2, by + bubbleH / 2);
    ctx.restore();
  }

  function segLabel(s) {
    if (s.type === 'straight') return 'Straight';
    if (s.type === 'corner') return 'Corner';
    return 'Chicane';
  }

  function segColor(type, a=1) {
    const map = {
      straight: `rgba(105, 226, 255, ${a})`,
      corner:   `rgba(255, 110, 64, ${a})`,
      chicane:  `rgba(242, 230, 160, ${a})`
    };
    return map[type] || `rgba(255,255,255,${a})`;
  }

  function absPosToScreenY(absPos) {
    if (!cameraState.scale) return cameraState.centerY;
    return cameraState.centerY - (absPos - cameraState.pos) * cameraState.scale;
  }

  function screenYToAbsPos(y) {
    if (!cameraState.scale) return cameraState.pos;
    return cameraState.pos + (cameraState.centerY - y) / cameraState.scale;
  }

  function mapTotalProgressToY(totalM, h, pad) {
    const span = h - pad*2;
    const t = clamp(totalM / TOTAL_LENGTH_M, 0, 1);
    return Math.round(h - pad - t * span);
  }

  function formatMeters(v) {
    return v.toLocaleString('en-US');
  }

  function formatInterval(sec, includeSign = false, includeUnit = true) {
    if (!isFinite(sec) || sec <= 0.05) {
      const base = '0.0';
      return includeUnit ? `${includeSign?'+':''}${base} s` : `${includeSign?'+':''}${base}`;
    }
    const sign = includeSign ? '+' : '';
    if (sec >= 60) {
      const mins = Math.floor(sec / 60);
      const rem = sec - mins * 60;
      const remStr = rem >= 10 ? rem.toFixed(1) : rem.toFixed(1).padStart(4, '0');
      return `${sign}${mins}:${remStr}`;
    }
    const suffix = includeUnit ? ' s' : '';
    return `${sign}${sec.toFixed(1)}${suffix}`;
  }

  function formatLapClock(sec) {
    if (!isFinite(sec) || sec <= 0) return '‚Äî';
    let minutes = Math.floor(sec / 60);
    let secondsFloat = sec - minutes * 60;
    let secWhole = Math.floor(secondsFloat);
    let millis = Math.round((secondsFloat - secWhole) * 1000);
    if (millis === 1000) {
      millis = 0;
      secWhole += 1;
      if (secWhole === 60) {
        secWhole = 0;
        minutes += 1;
      }
    }
    const secStr = String(secWhole).padStart(2, '0');
    const msStr = String(millis).padStart(3, '0');
    return `${minutes}:${secStr}.${msStr}`;
  }

  function formatLapSummary(d) {
    const last = d.lastLapTime != null ? formatLapClock(d.lastLapTime) : '‚Äî';
    const best = d.bestLapTime !== Infinity ? formatLapClock(d.bestLapTime) : '‚Äî';
    return `${last} / ${best}`;
  }

  function currentElapsedTime(d, now) {
    if (d.finishTime != null) return d.finishTime;
    const completed = d.lapTimes?.reduce((sum, t)=>sum + t, 0) ?? 0;
    const current = Math.max(0, now - (d.lapStartTime ?? now));
    return completed + current;
  }

  function applyCompoundToCar(car, key) {
    const compound = tyreCompounds[key] || tyreCompounds.hard;
    car.tyreCompound = key;
    car.tyreGripMult = compound.grip ?? 1;
    car.tyreWearMult = compound.wear ?? 1;
    const baseAccel = car.baseAccel ?? car.accel ?? 1;
    const baseWear = car.baseTyreDegradation ?? car.tyreDegradation ?? 0.3;
    car.accel = clamp01(baseAccel * (compound.accel ?? 1));
    car.tyreDegradation = baseWear * (compound.wear ?? 1);
  }

  function startPitStop(driver, lapsRemaining = null) {
    const pit = driver.pitStats || { baseTime:4, agility:0.85, luck:0.2, lane: PIT_LANE_TIME };
    let pitService = Math.max(0.5, pit.baseTime * pit.agility);
    if (Math.random() < (pit.luck ?? 0.2)) pitService = Math.max(0.5, pitService - 1.5);
    const total = pitService + (pit.lane ?? PIT_LANE_TIME);
    driver.inPit = true;
    driver.pitTimer = total;
    driver.lastPitService = pitService;
    driver.pitLapDisplay = 1;
    driver.pitJustExited = true;
    driver.v = 0;
    const targetCompound = choosePitCompound(driver, lapsRemaining);
    if (targetCompound) {
      driver.pitTargetCompound = targetCompound;
    }
  }

  function setSegmentDisplay(seg, index, source, opts = {}) {
    if (!segmentInfo || index < 0) return;
    const lapKey = opts.finished ? LAPS : (opts.lap ?? null);
    if (segmentState.source === source && segmentState.index === index && segmentState.lap === lapKey) return;
    segmentState = { source, index, lap: lapKey };
    segmentTag.className = `pill ${seg.type}`;
    segmentTag.textContent = segLabel(seg);
    if (source === 'player') {
      const lapLabel = opts.finished
        ? 'Finished'
        : `Lap ${Math.min((opts.lap ?? 0) + 1, LAPS)} / ${LAPS}`;
      segmentIndexEl.textContent = `Segment ${index + 1} / ${segments.length} ‚Ä¢ ${lapLabel}`;
    } else {
      const lapLabel = opts.lap != null ? ` ‚Äî Lap ${Math.min(opts.lap + 1, LAPS)}` : '';
      segmentIndexEl.textContent = `Segment ${index + 1} / ${segments.length} ‚Ä¢ Hover${lapLabel}`;
    }
    segmentRangeEl.textContent = `${formatMeters(seg.start)} ‚Äì ${formatMeters(seg.end)} m`;
    const len = seg.end - seg.start;
    segmentLengthEl.textContent = `Length: ${formatMeters(len)} m`;
    segmentGripEl.textContent = `Grip √ó${seg.grip.toFixed(2)}${seg.overtake ? ' ¬∑ Overtake window' : ''}`;
    segmentInfo.classList.add('visible');
  }

  function updateSegmentInfoForPlayer() {
    if (isHoveringSegment) return;
    const focus = drivers.find(d => d.id === cameraState.targetId) || drivers[0];
    if (!focus) return;
    const clampedPos = Math.max(0, Math.min(focus.pos, TOTAL_LENGTH_M));
    const lapRaw = Math.floor(clampedPos / TRACK_LENGTH_M);
    const lapPos = focus.finished ? TRACK_LENGTH_M - 1e-3 : (clampedPos % TRACK_LENGTH_M);
    const seg = currentSegment(lapPos);
    const idx = segments.indexOf(seg);
    setSegmentDisplay(seg, idx, 'player', { lap: lapRaw, finished: focus.finished });
  }

  function updateStatus() {
    const focus = drivers.find(d => d.id === cameraState.targetId) || drivers[0];
    const lapDisplay = focus
      ? Math.min(focus.finished ? LAPS : Math.max(0, Math.floor(focus.pos / TRACK_LENGTH_M) + 1), LAPS)
      : 0;
    if (finished) {
      statusEl.textContent = `Finished ‚Äî total time ${simTime.toFixed(2)} s (${LAPS} laps)`;
    } else if (!started) {
      statusEl.textContent = 'Ready';
    } else if (paused) {
      statusEl.textContent = `Paused ‚Äî Lap ${lapDisplay} / ${LAPS}`;
    } else {
      statusEl.textContent = `Racing ‚Äî Lap ${lapDisplay} / ${LAPS}`;
    }
  }

  function handleSegmentPointer(evt) {
    const rect = canvas.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const scaleY = canvas.height / rect.height;
    const y = (evt.clientY - rect.top) * scaleY;
    const absPos = clamp(screenYToAbsPos(y), 0, TOTAL_LENGTH_M);
    const lapPos = ((absPos % TRACK_LENGTH_M) + TRACK_LENGTH_M) % TRACK_LENGTH_M;
    const seg = currentSegment(lapPos);
    const idx = segments.indexOf(seg);
    if (!seg || idx < 0) return;
    isHoveringSegment = true;
    const lapIndex = Math.floor(absPos / TRACK_LENGTH_M);
    setSegmentDisplay(seg, idx, 'hover', { lap: lapIndex });
  }

  function handleSegmentLeave() {
    if (!isHoveringSegment) return;
    isHoveringSegment = false;
    segmentState = { source:'', index:-1, lap:null };
    updateSegmentInfoForPlayer();
  }

  // ---- CORE LOOP ----
  function applyLookaheadScaleToDrivers(list) {
    if (!Array.isArray(list)) return;
    for (const drv of list) {
      if (!drv) continue;
      const base = Number.isFinite(drv.baseLookaheadInterval) ? drv.baseLookaheadInterval : (drv.lookaheadInterval ?? 0.06);
      const scale = drv.isPlayer ? lookaheadScale : 1;
      const minInterval = drv.isPlayer ? 0.005 : 0.02;
      const scaled = clamp(base * scale, minInterval, 0.35);
      drv.lookaheadInterval = scaled;
      if (typeof drv.lookaheadTimer === 'number') {
        drv.lookaheadTimer = Math.min(Math.max(0, drv.lookaheadTimer), scaled);
      } else {
        drv.lookaheadTimer = 0;
      }
    }
  }

  let drivers = createDriversForMode(sessionMode);
  applyLookaheadScaleToDrivers(drivers);
  applyGridPositions(drivers);
  cameraState.targetId = drivers[0]?.id ?? 0;
  resetSpeedGraph(drivers[0] ?? null);
  sampleSpeedGraph(drivers[0] ?? null, { force: true });
  speedGraphReady = true;
  renderSpeedGraph();
  let started = false, finished = false, paused = false;
  let simTime = 0;          // simulated race time in seconds
  let lastT = 0, acc = 0;   // accumulator for fixed-step
  updateSegmentInfoForPlayer();

  if (lookaheadScaleInput) {
    const handleLookaheadScaleChange = () => {
      const raw = parseFloat(lookaheadScaleInput.value);
      if (!Number.isFinite(raw)) return;
      lookaheadScale = Math.max(0.1, Math.min(3, raw));
      lookaheadScaleInput.title = `${lookaheadScale.toFixed(2)}√ó`;
      applyLookaheadScaleToDrivers(drivers);
    };
    lookaheadScaleInput.addEventListener('input', handleLookaheadScaleChange);
    lookaheadScaleInput.addEventListener('change', handleLookaheadScaleChange);
  }

  function step(dt) {
    acc += dt * simSpeed;
    while (acc >= TICK_RATE) {
      integrate(TICK_RATE);
      const focusForGraph = getFocusDriver();
      if (focusForGraph) sampleSpeedGraph(focusForGraph);
      acc -= TICK_RATE;
      simTime += TICK_RATE;
      if (paused) {
        acc = 0;
        break;
      }
    }
  }

  function integrate(dt) {
    let allDone = true;
    const intervalUpdates = new Set();
    const stepTime = dt;
    const timeAfterStep = simTime + stepTime;
    const positionOrder = [...drivers].sort((a,b)=>b.pos - a.pos);
    const aheadMap = new Map();
    for (let i=1; i<positionOrder.length; i++) {
      aheadMap.set(positionOrder[i].id, positionOrder[i-1]);
    }
    for (const d of drivers) {
      d.uiSpeedBoost = 0;
      d.uiSpeedPenalty = 0;
      d.uiSpeedBoostSources = [];
      d.uiSpeedPenaltySources = [];
    }
    const attackBoosts = new Map();
    const targetPenalties = new Map();
    const boostSources = new Map();
    const penaltySources = new Map();
    const cornerEntries = [];
    for (let i=0; i<positionOrder.length-1; i++) {
      const ahead = positionOrder[i];
      const behind = positionOrder[i+1];
      if (ahead.finished || behind.finished) continue;
      const gap = ahead.pos - behind.pos;
      if (gap <= 0 || gap > 12) continue;
      const aheadLap = Math.floor(ahead.pos / TRACK_LENGTH_M);
      const behindLap = Math.floor(behind.pos / TRACK_LENGTH_M);
      if (aheadLap !== behindLap) continue;
      const slip = clamp((12 - gap) / 12, 0, 1);
      const attack = clamp01(behind.driverStats?.racecraft ?? 0.5);
      const defence = clamp01(ahead.driverStats?.defense ?? 0.5);
      const diff = attack - defence;
      if (diff >= 0) {
        const boost = diff * slip * 0.25;
        if (boost > 0) {
          const prev = attackBoosts.get(behind.id) ?? 0;
          const next = Math.max(prev, boost);
          attackBoosts.set(behind.id, next);
          const tags = boostSources.get(behind.id) ?? [];
          if (!tags.includes('slipstream')) tags.push('slipstream');
          boostSources.set(behind.id, tags);
        }
        const aheadDrag = diff * slip * 0.05;
        if (aheadDrag > 0) {
          const prev = targetPenalties.get(ahead.id) ?? 0;
          const next = Math.max(prev, aheadDrag);
          targetPenalties.set(ahead.id, next);
          const tags = penaltySources.get(ahead.id) ?? [];
          if (!tags.includes('encounter-drag')) tags.push('encounter-drag');
          penaltySources.set(ahead.id, tags);
        }
      } else {
        const block = (-diff) * slip * 0.2;
        if (block > 0) {
          const prev = targetPenalties.get(behind.id) ?? 0;
          const next = Math.max(prev, block);
          targetPenalties.set(behind.id, next);
          const tags = penaltySources.get(behind.id) ?? [];
          if (!tags.includes('encounter-fail')) tags.push('encounter-fail');
          penaltySources.set(behind.id, tags);
        }
      }
    }
    const timeCache = new Map();
    const getTimeFor = (driver) => {
      if (!driver) return simTime;
      if (!timeCache.has(driver.id)) {
        timeCache.set(driver.id, currentElapsedTime(driver, timeAfterStep));
      }
      return timeCache.get(driver.id);
    };
    for (const d of drivers) {
      if (d.finished) continue;
      if (d.inPit) {
        d.v = 0;
        d.drsActiveSegment = null;
        d.drsZoneId = null;
        d.drsGranted = false;
        d.drsEntryGap = null;
        d.pitTimer -= stepTime;
        if (d.pitTimer <= 0) {
          d.inPit = false;
          d.pitTimer = 0;
          if (d.carStats) {
            let selectedCompound = null;
            if (Array.isArray(d.tyreInventory) && d.tyreInventory.length > 0) {
              selectedCompound = drawTyreSet(d.tyreInventory, d.pitTargetCompound);
            }
            const targetCompound = selectedCompound ?? d.pitTargetCompound ?? d.carStats.tyreCompound ?? 'hard';
            applyCompoundToCar(d.carStats, targetCompound);
            d.carStats.tyreCondition = 1;
            if (!Array.isArray(d.tyreHistory)) d.tyreHistory = [];
            d.tyreHistory.push(targetCompound);
          }
          d.pitTargetCompound = null;
          d.pitLapDisplay = 1;
          d.pitJustExited = true;
          d.drsActiveSegment = null;
          d.drsZoneId = null;
          d.drsGranted = false;
          d.drsEntryGap = null;
        } else {
          allDone = false;
          continue;
        }
      }
      const prevLapCount = d.lap ?? 0;
      const lapPos = d.finished ? TRACK_LENGTH_M - 1e-3 : ((d.pos % TRACK_LENGTH_M) + TRACK_LENGTH_M) % TRACK_LENGTH_M;
      const prevSegType = d.segmentType || 'straight';
      const seg = currentSegment(lapPos);
      const segIdx = segments.indexOf(seg);
      const zoneId = seg.drs ? (seg.drsId ?? segIdx) : null;
      const aheadDriver = aheadMap.get(d.id);
      const enteringSegment = d.segmentIndex !== segIdx;
      if (enteringSegment) {
        d.segmentIndex = segIdx;
        intervalUpdates.add(d.id);
      }
      if (seg.drs) {
        const enteringZone = d.drsZoneId !== zoneId;
        if (enteringZone) {
          let eligible = false;
          if (aheadDriver && !aheadDriver.isDNF) {
            const aheadLap = Math.floor(aheadDriver.pos / TRACK_LENGTH_M);
            const driverLap = Math.floor(d.pos / TRACK_LENGTH_M);
            const gapDist = aheadDriver.pos - d.pos;
            const closeOnWrap = aheadLap === driverLap + 1 && gapDist <= 180;
            const sameLap = aheadLap === driverLap;
            if (sameLap || closeOnWrap) {
              const gapTimeEntry = Math.max(0, (getTimeFor(d) ?? 0) - (getTimeFor(aheadDriver) ?? 0));
              if (gapTimeEntry <= 1 && gapDist <= 180) {
                eligible = true;
                d.drsEntryGap = gapTimeEntry;
              }
            }
          }
          d.drsZoneId = zoneId;
          if (eligible) {
            d.drsGranted = true;
            d.drsActiveSegment = segIdx;
            if (aheadDriver) intervalUpdates.add(aheadDriver.id);
          } else {
            d.drsGranted = false;
            d.drsActiveSegment = null;
            d.drsEntryGap = null;
          }
        } else if (d.drsGranted && d.drsZoneId === zoneId) {
          d.drsActiveSegment = segIdx;
        }
      } else {
        if (d.drsZoneId !== null || d.drsGranted) intervalUpdates.add(d.id);
        d.drsZoneId = null;
        d.drsGranted = false;
        d.drsActiveSegment = null;
        d.drsEntryGap = null;
      }
      const drsActive = seg.drs && d.drsGranted && d.drsZoneId === zoneId;
      let dirtyAir = false;
      if (!seg.drs && seg.type !== 'straight') {
        if (aheadDriver && !aheadDriver.isDNF) {
          const gapTime = Math.max(0, getTimeFor(d) - getTimeFor(aheadDriver));
          if (gapTime <= 1 && (aheadDriver.pos - d.pos) < 150) dirtyAir = true;
        }
      }
      const car = d.carStats;
      const pilot = d.driverStats;
      const driverTopFactor = clamp(pilot.topSpeed ?? 1, 0.7, 1.1);
      let topSpeed = ((car.topSpeed ?? 350) * driverTopFactor) / 3.6;
      const accelFactor = clamp((car.accel ?? 1) * (pilot.accel ?? 1), 0.2, 2);
      let accelRate = (car.maxAccelRate ?? (9 + 9 * clamp(car.baseAccel ?? 0.8, 0, 1))) * (0.7 + accelFactor * 0.6) * 0.8;
      const brakeSkill = clamp01(pilot.braking ?? 0.5);
      let brakeRate = (car.maxBrakeRate ?? (26 + 12 * clamp(car.baseHandling ?? 0.8, 0, 1))) * (0.85 + brakeSkill * 0.45);
      brakeRate = Math.max(brakeRate, 18);
      const highSpeedBrakeBoost = clamp01(d.v / 90);
      brakeRate += highSpeedBrakeBoost * 6;
      if (drsActive) {
        topSpeed *= 1.12;
        accelRate *= 1.05;
        d.uiSpeedBoost = Math.max(d.uiSpeedBoost ?? 0, 0.10);
        if (!d.uiSpeedBoostSources.includes('drs')) d.uiSpeedBoostSources.push('drs');
      }
      if (dirtyAir) {
        accelRate *= 0.94;
        topSpeed *= 0.98;
        const applied = 0.05;
        d.uiSpeedPenalty = Math.max(d.uiSpeedPenalty ?? 0, applied);
        if (!d.uiSpeedPenaltySources.includes('dirty-air')) d.uiSpeedPenaltySources.push('dirty-air');
      }
      if (d.overtakeBoostTimer > 0 && d.overtakeBoostTop > 0) {
        const topBoost = Math.min(0.25, d.overtakeBoostTop);
        topSpeed *= 1 + topBoost;
      }
      if (d.overtakeBoostTimer > 0 && d.overtakeBoostAccel > 0) {
        const accelBoost = Math.min(0.3, d.overtakeBoostAccel);
        accelRate *= 1 + accelBoost;
      }
      if (d.overtakeTimer > 0 && d.overtakePenalty > 0) {
        const penaltyMult = Math.max(0.6, 1 - d.overtakePenalty);
        accelRate *= penaltyMult;
        topSpeed *= penaltyMult;
        if (d.overtakePenaltySource === 'fail') {
          const applied = 1 - penaltyMult;
          if (applied > 0) {
            d.uiSpeedPenalty = Math.max(d.uiSpeedPenalty ?? 0, applied);
            if (!d.uiSpeedPenaltySources.includes('unsuccessful')) d.uiSpeedPenaltySources.push('unsuccessful');
          }
        }
      }
      const boost = attackBoosts.get(d.id);
      if (boost) {
        accelRate *= 1 + boost;
        topSpeed *= 1 + boost * 0.4;
        d.uiSpeedBoost = Math.max(d.uiSpeedBoost ?? 0, boost);
        const tags = boostSources.get(d.id);
        if (tags) {
          for (const tag of tags) {
            if (!d.uiSpeedBoostSources.includes(tag)) d.uiSpeedBoostSources.push(tag);
          }
        }
      }
      const penalty = targetPenalties.get(d.id);
      if (penalty) {
        const penaltyMult = Math.max(0.55, 1 - penalty);
        accelRate *= penaltyMult;
        topSpeed *= Math.max(0.6, penaltyMult);
        const tags = penaltySources.get(d.id) ?? [];
        if (tags.includes('encounter-fail')) {
          const applied = 1 - penaltyMult;
          if (applied > 0) {
            d.uiSpeedPenalty = Math.max(d.uiSpeedPenalty ?? 0, applied);
            if (!d.uiSpeedPenaltySources.includes('unsuccessful')) d.uiSpeedPenaltySources.push('unsuccessful');
          }
        }
      }
      const apexInfo = nextCornerApexAfter(d.pos);
      const pedals = planPedalInputs(d, {
        seg,
        apexInfo,
        topSpeed,
        brakeRate,
        dt
      });
      const throttle = clamp01(pedals.throttle);
      const brake = pedals.brake ? 1 : 0;
      const prevV = d.v;
      let effectiveAccel = accelRate * throttle;
      const speedRatio = topSpeed > 0 ? clamp(prevV / topSpeed, 0, 1) : 0;
      const saturation = speedRatio * speedRatio * speedRatio;
      effectiveAccel *= Math.max(0, 1 - saturation * 0.98);
      let decel = brake ? brakeRate : 0;
      if (!brake && throttle < 0.05) {
        decel = Math.max(decel, 2 + 3 * (prevV / Math.max(1, topSpeed)));
      }
      let nextV = prevV + (effectiveAccel - decel) * dt;
      if (nextV < 0) nextV = 0;
      if (nextV > topSpeed) nextV = topSpeed;
      const avgV = (prevV + nextV) * 0.5;
      const distanceTravelled = Math.max(0, avgV * dt);
      d.v = nextV;
      d.pos += distanceTravelled;
      const distanceToApex = apexInfo ? apexInfo.distance : Infinity;
      if (apexInfo && apexInfo.seg === seg && distanceToApex <= Math.max(1.5, prevV * dt)) {
        const apexSpeed = apexInfo.apexSpeed;
        if (prevV > apexSpeed * 1.05) {
          d.missedApex = (d.missedApex ?? 0) + 1;
          d.v = Math.min(d.v, apexSpeed);
        }
      }
      const change = nextV - prevV;
      const tyre = d.carStats;
      let degradeBase = seg.type !== 'straight' ? 1 : 0.15;
      if (brake) degradeBase += 0.45;
      if (throttle > 0.75) degradeBase += 0.1;
      if (change > 0.5) degradeBase += 0.05;
      const loss = tyre.tyreDegradation * degradeBase * distanceTravelled * TYRE_DEGRADE_PER_M * (pilot.tyreManagement ?? 1);
      tyre.tyreCondition = clamp01((tyre.tyreCondition ?? 1) - loss);
      const currentLapCount = Math.max(0, Math.floor(d.pos / TRACK_LENGTH_M));
      const justCompletedLap = currentLapCount > prevLapCount;
      if (justCompletedLap) {
        const lapTime = Math.max(0, timeAfterStep - d.lapStartTime);
        if (lapTime > 0) {
          d.lastLapTime = lapTime;
          d.lapTimes.push(lapTime);
          if (lapTime < d.bestLapTime) d.bestLapTime = lapTime;
          if (lapTime < fastestLapTime) fastestLapTime = lapTime;
        }
        d.lapStartTime = timeAfterStep;
        if (d.pitJustExited) {
          d.pitJustExited = false;
        } else if (d.pitLapDisplay > 0) {
          d.pitLapDisplay = Math.max(0, d.pitLapDisplay - 1);
          if (d.pitLapDisplay === 0) d.lastPitService = null;
        }
        const tyreCondition = d.carStats?.tyreCondition ?? 1;
        const travelled = Math.max(0, d.pos);
        const distanceRemaining = Math.max(0, TOTAL_LENGTH_M - travelled);
        const lapsRemaining = distanceRemaining / TRACK_LENGTH_M;
        if (!d.inPit && tyreCondition <= 0.3 && !d.finished && lapsRemaining > 2) {
          startPitStop(d, lapsRemaining);
        }
      }
      if (d.overtakeTimer > 0) {
        d.overtakeTimer = Math.max(0, d.overtakeTimer - stepTime);
        if (d.overtakeTimer === 0) {
          d.overtakePenalty = 0;
          d.overtakePenaltySource = null;
        }
      }
      if (d.overtakeBoostTimer > 0) {
        d.overtakeBoostTimer = Math.max(0, d.overtakeBoostTimer - stepTime);
        if (d.overtakeBoostTimer === 0) {
          d.overtakeBoostAccel = 0;
          d.overtakeBoostTop = 0;
        }
      }
      const newLapPos = d.finished ? TRACK_LENGTH_M - 1e-3 : ((d.pos % TRACK_LENGTH_M) + TRACK_LENGTH_M) % TRACK_LENGTH_M;
      const segAfter = currentSegment(newLapPos);
      const segTypeAfter = segAfter.type;
      const isBattleSegment = segTypeAfter === 'corner' || segTypeAfter === 'chicane' || segTypeAfter === 'straight';
      if (segTypeAfter !== prevSegType && isBattleSegment) {
        cornerEntries.push({ driverId: d.id, segType: segTypeAfter, difficulty: segAfter.difficulty ?? 1 });
        intervalUpdates.add(d.id);
      }
      d.segmentType = segTypeAfter;
      if (d.pos >= TOTAL_LENGTH_M) {
        d.pos = TOTAL_LENGTH_M;
        d.finished = true;
        d.finishTime = timeAfterStep;
        d.v = 0;
      }
      d.lap = d.finished ? LAPS : currentLapCount;
      if (!d.finished) allDone = false;
    }
    const ordered = [...drivers].sort((a,b)=>b.pos - a.pos || (a.finishTime??Infinity) - (b.finishTime??Infinity));
    const lead = ordered[0];
    if (intervalUpdates.size) {
      const approxLapTimeBase = fastestLapTime !== Infinity ? fastestLapTime : null;
      for (let i = 0; i < ordered.length; i++) {
        const d = ordered[i];
        const followerFlagged = i + 1 < ordered.length && intervalUpdates.has(ordered[i + 1].id);
        if (!intervalUpdates.has(d.id) && !followerFlagged) continue;
        if (d.isDNF) {
          d.intervalDisplay = '<span style="color:#bd93f9;font-weight:600">DNF</span>';
          continue;
        }
        if (i === 0) {
          d.intervalDisplay = '+0.0 s';
          continue;
        }
        const ahead = ordered[i - 1];
        const driverTimeNow = currentElapsedTime(d, simTime);
        const targetTime = currentElapsedTime(ahead, simTime);
        let gapSec = Math.max(0, driverTimeNow - targetTime);
        const approxLapTime = approxLapTimeBase;
        const completedDiff = Math.max(0, (ahead.lapTimes?.length ?? 0) - (d.lapTimes?.length ?? 0));
        const distanceGapM = Math.max(0, ahead.pos - d.pos);
        if (gapSec < 0.05 && distanceGapM > 0.1) {
          const avgSpeedRaw = ((ahead.v ?? 0) + (d.v ?? 0)) * 0.5;
          if (avgSpeedRaw > 1) {
            const avgSpeed = Math.max(1, avgSpeedRaw);
            gapSec = distanceGapM / avgSpeed;
          }
        }
        let display = formatInterval(gapSec, true, false);
        if (approxLapTime && gapSec >= approxLapTime) {
          const lapsBehindByTime = Math.max(1, Math.round(gapSec / approxLapTime));
          const lapsBehind = Math.max(lapsBehindByTime, completedDiff);
          display = `${display} (+${lapsBehind} lap${lapsBehind>1?'s':''})`;
        } else if (!approxLapTime && completedDiff > 0) {
          const lapsBehind = completedDiff;
          display = `${display} (+${lapsBehind} lap${lapsBehind>1?'s':''})`;
        }
        d.intervalDisplay = display;
      }
    }
    if (cornerEntries.length) {
      for (const entry of cornerEntries) {
        const idx = ordered.findIndex(d=>d.id === entry.driverId);
        if (idx <= 0) continue;
        const attacker = ordered[idx];
        const defender = ordered[idx-1];
        if (!attacker || !defender) continue;
        const gap = defender.pos - attacker.pos;
        if (gap > OVERTAKE_GAP_THRESHOLD) continue;
        attacker.overtakeTotal = (attacker.overtakeTotal ?? 0) + 1;
        const segmentType = entry.segType;
        const defenceSkill = clamp01(defender.driverStats?.defense ?? 0.5);
        let attackSkill = clamp01(attacker.driverStats?.racecraft ?? 0.5);
        const difficulty = entry.difficulty ?? 1;
        attackSkill = clamp01(attackSkill * difficulty);
        const attackRoll = Math.random();
        const defenceRoll = Math.random();
        const attackOutcome = attackSkill * attackRoll;
        const defenceOutcome = defenceSkill * defenceRoll;
        const attackCritical = attackOutcome < 0.001;
        const defenceCritical = defenceOutcome < 0.001;
        if (attackCritical && !defenceCritical) {
          attacker.overtakeFail = (attacker.overtakeFail ?? 0) + 1;
          attacker.overtakeTotal = (attacker.overtakeTotal ?? 0) + 1;
          setDNF(attacker, timeAfterStep);
          continue;
        }
        if (defenceCritical && !attackCritical) {
          attacker.overtakeSuccess = (attacker.overtakeSuccess ?? 0) + 1;
          attacker.overtakeTotal = (attacker.overtakeTotal ?? 0) + 1;
          setDNF(defender, timeAfterStep);
          continue;
        }
        if (attackSkill + 0.05 >= defenceSkill) {
          attacker.overtakeSuccess = (attacker.overtakeSuccess ?? 0) + 1;
          const successFactor = clamp01(1 - defenceOutcome);
          const accelBoost = Math.min(0.08, 0.04 + successFactor * 0.08);
          const topBoost = Math.min(0.08, 0.02 + successFactor * 0.06);
          const successEffect = {
            strength: 0.20,
            duration: 12
          };
          defender.overtakePenaltySource = 'defence';
          applyOvertakePenalty(defender, successEffect);
          applyOvertakeBoost(attacker, accelBoost, topBoost, 1.5);
        } else {
          attacker.overtakeFail = (attacker.overtakeFail ?? 0) + 1;
          const failFactor = clamp01(1 - attackOutcome);
          const failEffect = {
            strength: clamp(OVERTAKE_FAIL_PENALTY.strength * (0.5 + failFactor * 0.5), 0.05, 0.3),
            duration: OVERTAKE_FAIL_PENALTY.duration
          };
          attacker.overtakePenaltySource = 'fail';
          applyOvertakePenalty(attacker, failEffect);
        }
      }
    }
    if (allDone) {
      finished = true;
      started = false;
      paused = false;
      updateControls();
      updateStatus();
    }
  }

  function render() {
    const focusDriver = getFocusDriver();
    if (focusDriver) sampleSpeedGraph(focusDriver);
    renderSpeedGraph();
    drawTrack(drivers);
    renderTable();
    updateSegmentInfoForPlayer();
    updateStatus();
  }

  function renderSpeedGraph() {
    if (!speedGraphCanvas || !speedGraphCtx) return;
    if (!speedGraphCanvas.width || !speedGraphCanvas.height) resizeSpeedGraph();
    const width = speedGraphCanvas.width;
    const height = speedGraphCanvas.height;
    if (!width || !height) return;

    const ctx = speedGraphCtx;
    const dpr = speedGraphState.dpr || Math.max(1, window.devicePixelRatio || 1);
    const plotPadding = {
      left: 52 * dpr,
      right: 18 * dpr,
      top: 22 * dpr,
      bottom: 28 * dpr,
    };
    const plotWidth = Math.max(1, width - plotPadding.left - plotPadding.right);
    const plotHeight = Math.max(1, height - plotPadding.top - plotPadding.bottom);

    const focus = getFocusDriver();
    const panelColor = getCSS('--panel') || '#13161b';
    ctx.fillStyle = panelColor;
    ctx.fillRect(0, 0, width, height);
    if (!focus) return;

    if (!speedGraphState.points.length) sampleSpeedGraph(focus, { force: true });

    ctx.save();
    ctx.translate(plotPadding.left, plotPadding.top);

    const points = speedGraphState.points;
    const prevPoints = Array.isArray(speedGraphState.prevPoints) ? speedGraphState.prevPoints : [];
    let maxObserved = focus.carStats?.topSpeed ?? 340;
    const check = list => {
      for (const p of list) if (Number.isFinite(p?.speed) && p.speed > maxObserved) maxObserved = p.speed;
    };
    check(points);
    check(prevPoints);
    const maxSpeed = Math.max(120, maxObserved * 1.05);
    const minSpeed = 0;

    const valueToY = (speedKmh) => {
      if (!Number.isFinite(speedKmh)) return plotHeight;
      const norm = clamp((speedKmh - minSpeed) / (maxSpeed - minSpeed || 1), 0, 1);
      return plotHeight - norm * plotHeight;
    };
    const ratioFrom = (pos) => (TRACK_LENGTH_M > 0 ? ((pos % TRACK_LENGTH_M) + TRACK_LENGTH_M) % TRACK_LENGTH_M : 0) / TRACK_LENGTH_M;

    // vertical markers for segments / corners
    ctx.lineWidth = Math.max(1, dpr * 0.5);
    ctx.strokeStyle = 'rgba(147, 161, 179, 0.18)';
    for (let i = 1; i < segments.length; i++) {
      const seg = segments[i];
      const boundaryRatio = ratioFrom(seg.start);
      const x = boundaryRatio * plotWidth;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, plotHeight);
      ctx.stroke();
    }

    // horizontal grid
    ctx.lineWidth = Math.max(1, dpr * 0.75);
    ctx.strokeStyle = 'rgba(147, 161, 179, 0.18)';
    ctx.font = `${10 * dpr}px system-ui`;
    ctx.fillStyle = 'rgba(231, 238, 247, 0.65)';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    const horizontalSteps = 4;
    for (let i = 0; i <= horizontalSteps; i++) {
      const ratio = i / horizontalSteps;
      const y = plotHeight * ratio;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(plotWidth, y);
      ctx.stroke();
      const label = Math.round(maxSpeed - (maxSpeed - minSpeed) * ratio);
      ctx.fillText(`${label}`, -6 * dpr, y);
    }
    ctx.textBaseline = 'top';
    ctx.font = `600 ${10 * dpr}px system-ui`;
    ctx.fillStyle = 'rgba(147, 161, 179, 0.7)';
    ctx.fillText('km/h', -6 * dpr, -10 * dpr);

    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = `${10 * dpr}px system-ui`;
    ctx.fillStyle = 'rgba(147, 161, 179, 0.6)';
    if (cornerMarkers.length) {
      for (const marker of cornerMarkers) {
        const x = ratioFrom(marker.start) * plotWidth;
        ctx.beginPath();
        ctx.moveTo(x, plotHeight);
        ctx.lineTo(x, plotHeight + 6 * dpr);
        ctx.stroke();
        ctx.fillText(`T${marker.index}`, x, plotHeight + 8 * dpr);
        if (Number.isFinite(marker.apex)) {
          const ax = ratioFrom(marker.apex) * plotWidth;
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 200, 165, 0.25)';
          ctx.lineWidth = 1 * dpr;
          ctx.setLineDash([2 * dpr, 6 * dpr]);
          ctx.beginPath();
          ctx.moveTo(ax, 0);
          ctx.lineTo(ax, plotHeight);
          ctx.stroke();
          ctx.setLineDash([]);
          if (Number.isFinite(marker.apexSpeed)) {
            const apexY = valueToY(marker.apexSpeed * 3.6);
            ctx.fillStyle = 'rgba(200, 130, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(ax, apexY, 3 * dpr, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
      }
    }
    if (drsMarkers.length) {
      ctx.strokeStyle = 'rgba(105, 226, 255, 0.4)';
      ctx.fillStyle = 'rgba(105, 226, 255, 0.75)';
      ctx.textBaseline = 'top';
      for (const marker of drsMarkers) {
        const x = ratioFrom(marker.start) * plotWidth;
        ctx.beginPath();
        ctx.moveTo(x, plotHeight);
        ctx.lineTo(x, plotHeight + 12 * dpr);
        ctx.stroke();
        ctx.fillText(marker.label, x, plotHeight + 14 * dpr);
      }
    }

    const drawLine = (pts, color, width) => {
      if (!Array.isArray(pts) || pts.length < 2) return;
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.moveTo(clamp(pts[0].x, 0, 1) * plotWidth, valueToY(pts[0].speed));
      for (let i = 1; i < pts.length; i++) {
        const p = pts[i];
        ctx.lineTo(clamp(p.x, 0, 1) * plotWidth, valueToY(p.speed));
      }
      ctx.stroke();
    };

    drawLine(prevPoints, 'rgba(147, 161, 179, 0.45)', 1 * dpr);
    drawLine(points, 'rgba(255, 106, 214, 0.95)', 1.6 * dpr);

    const pedalBand = Math.min(Math.max(plotHeight * 0.28, 20 * dpr), Math.max(32 * dpr, plotHeight));
    let pedalBase = plotHeight - 6 * dpr;
    if (pedalBase - pedalBand < 0) {
      pedalBase = plotHeight;
    }
    const pedalToY = (value) => {
      const v = clamp01(Number.isFinite(value) ? value : 0);
      const y = pedalBase - v * pedalBand;
      return clamp(y, 0, plotHeight);
    };
    ctx.strokeStyle = 'rgba(147, 161, 179, 0.22)';
    ctx.lineWidth = Math.max(1, 0.6 * dpr);
    ctx.beginPath();
    ctx.moveTo(0, pedalBase);
    ctx.lineTo(plotWidth, pedalBase);
    ctx.stroke();
    ctx.setLineDash([4 * dpr, 6 * dpr]);
    ctx.beginPath();
    ctx.moveTo(0, pedalToY(1));
    ctx.lineTo(plotWidth, pedalToY(1));
    ctx.stroke();
    ctx.setLineDash([]);

    const drawPedalLine = (pts, accessor, color, width) => {
      if (!Array.isArray(pts) || pts.length < 2) return;
      let started = false;
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        const raw = accessor(p);
        const val = clamp01(Number.isFinite(raw) ? raw : 0);
        const x = clamp(p.x, 0, 1) * plotWidth;
        const y = pedalToY(val);
        if (!started) {
          ctx.moveTo(x, y);
          started = true;
        } else {
          ctx.lineTo(x, y);
        }
      }
      if (started) ctx.stroke();
    };

    drawPedalLine(points, p => clamp01(p.throttle ?? 0), 'rgba(123, 216, 143, 0.85)', 1.2 * dpr);
    drawPedalLine(points, p => clamp01(p.brake ?? 0), 'rgba(255, 107, 107, 0.85)', 1.2 * dpr);

    ctx.font = `${9 * dpr}px system-ui`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    const pedalLegendThrottleY = clamp(pedalBase - pedalBand * 0.35, 0, plotHeight);
    const pedalLegendBrakeY = clamp(pedalBase - pedalBand * 0.7, 0, plotHeight);
    ctx.fillStyle = 'rgba(123, 216, 143, 0.9)';
    ctx.fillText('Throttle', 6 * dpr, pedalLegendThrottleY);
    ctx.fillStyle = 'rgba(255, 107, 107, 0.9)';
    ctx.fillText('Brake', 6 * dpr, pedalLegendBrakeY);

    const lapPos = focus.finished ? TRACK_LENGTH_M - 1e-3 : ((focus.pos % TRACK_LENGTH_M) + TRACK_LENGTH_M) % TRACK_LENGTH_M;
    const progressX = ratioFrom(lapPos) * plotWidth;
    ctx.strokeStyle = 'rgba(105, 226, 255, 0.35)';
    ctx.lineWidth = 1.2 * dpr;
    ctx.beginPath();
    ctx.moveTo(progressX, 0);
    ctx.lineTo(progressX, plotHeight);
    ctx.stroke();

    ctx.restore();

    ctx.fillStyle = 'rgba(231, 238, 247, 0.9)';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    ctx.font = `600 ${12 * dpr}px system-ui`;
    const speedDisplay = Math.round(Math.max(0, (focus.v ?? 0) * 3.6));
    ctx.fillText(`${speedDisplay} km/h`, width - 16 * dpr, 12 * dpr);

    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(231, 238, 247, 0.85)';
    ctx.font = `600 ${11 * dpr}px system-ui`;
    ctx.fillText(focus.name || 'Driver', 16 * dpr, 12 * dpr);

    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    ctx.font = `${10 * dpr}px system-ui`;
    ctx.fillStyle = 'rgba(147, 161, 179, 0.7)';
    const lapDisplay = Math.min(LAPS, (focus.lap ?? 0) + 1);
    ctx.fillText(`Lap ${lapDisplay} / ${LAPS}`, width - 16 * dpr, height - 12 * dpr);
  }

  function renderTable() {
    const selection = window.getSelection && window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      if (range && tbl.contains(range.commonAncestorContainer) && selection.type === 'Range') {
        return;
      }
    }
    const isGridPhase = !started && !finished;
    const order = [...drivers].sort((a, b) => {
      if (isGridPhase) {
        const slotA = Number.isFinite(a.startSlot) ? a.startSlot : Number.MAX_SAFE_INTEGER;
        const slotB = Number.isFinite(b.startSlot) ? b.startSlot : Number.MAX_SAFE_INTEGER;
        if (slotA !== slotB) return slotA - slotB;
        return a.id - b.id;
      }
      const posDiff = (b.pos ?? 0) - (a.pos ?? 0);
      if (posDiff !== 0 && Number.isFinite(posDiff)) return posDiff;
      const finishA = Number.isFinite(a.finishTime) ? a.finishTime : Infinity;
      const finishB = Number.isFinite(b.finishTime) ? b.finishTime : Infinity;
      if (finishA !== finishB) return finishA - finishB;
      return (a.startSlot ?? Number.MAX_SAFE_INTEGER) - (b.startSlot ?? Number.MAX_SAFE_INTEGER);
    });
    const focusId = cameraState.targetId ?? (drivers[0]?.id ?? 0);
    tbl.innerHTML = order.map((d,idx)=>{
      const gap = d.intervalDisplay ?? (idx === 0 ? '+0.0 s' : '‚Äî');
      const spd = d.v * 3.6;
      const spdDisplay = Math.round(spd);
      const baseTop = Math.max(1, (d.carStats?.topSpeed ?? 360));
      const flag = `<span class="flag">${d.flag || 'üèÅ'}</span>`;
      const isFocus = d.id === focusId;
      let name = `<strong>${d.name}</strong>`;
      if (d.id === 0) {
        name = `<strong style="color:var(--player)">${d.name}</strong>`;
      }
      if (isFocus && d.id !== 0) {
        name = `<strong style="color:var(--accent)">${d.name}</strong>`;
      }
      const playerTeam = drivers[0]?.team;
      const isPlayerTeam = d.team && d.team === playerTeam;
      const teamColor = isPlayerTeam ? 'var(--player)' : (d.teamColor || '#93a1b3');
      const teamLine = d.team
        ? `<span class="tiny" style="display:block;color:${teamColor}">${d.team}</span>`
        : '';
      let tyreCell = '';
      if (d.inPit) {
        tyreCell = `<span class="in-pit">IN PIT</span>`;
      } else if (!d.pitJustExited && d.pitLapDisplay > 0 && d.lastPitService != null) {
        tyreCell = `<span class="pit-time">${d.lastPitService.toFixed(1)} s</span>`;
      } else {
        const tyrePct = Math.round(((d.carStats?.tyreCondition ?? 1) * 100));
        const compoundKey = d.carStats?.tyreCompound || 'hard';
        const labelMap = { hard:'H', medium:'M', soft:'S' };
        const colorMap = { hard:'#ffffff', medium:'#f9d748', soft:'#ff4d4d' };
        const letter = labelMap[compoundKey] || 'H';
        const ringColor = colorMap[compoundKey] || '#ffffff';
      tyreCell = `<span class="tyre-badge"><span class="tyre-ring" style="color:${ringColor}">${letter}</span><span>${tyrePct}%</span></span>`;
      }
      const lapSummary = formatLapSummary(d);
      const basePercent = baseTop > 0 ? Math.min(100, Math.round((Math.min(spd, baseTop) / baseTop) * 100)) : 0;
      const boostActive = (d.uiSpeedBoost ?? 0) > 0 && d.uiSpeedBoostSources?.some(tag => tag === 'drs' || tag === 'slipstream');
      const penaltyActive = (d.uiSpeedPenalty ?? 0) > 0 && d.uiSpeedPenaltySources?.some(tag => tag === 'dirty-air' || tag === 'unsuccessful');
      const penaltyWidth = penaltyActive ? Math.min(100, Math.round((d.uiSpeedPenalty ?? 0) * 100)) : 0;
      const penaltyLeft = Math.max(0, basePercent - penaltyWidth);
      const boostWidth = boostActive ? Math.min(100, Math.round((d.uiSpeedBoost ?? 0) * 100)) : 0;
      const boostLeft = Math.min(100, basePercent);
      const speedLayers = [`<div class=\"speed-fill base\" style=\"width:${basePercent}%\"></div>`];
      if (penaltyWidth > 0) {
        speedLayers.push(`<div class=\"speed-fill dirty\" style=\"left:${penaltyLeft}%; width:${penaltyWidth}%\"></div>`);
      }
      if (boostWidth > 0) {
        speedLayers.push(`<div class=\"speed-fill boost\" style=\"left:${boostLeft}%; width:${boostWidth}%\"></div>`);
      }
      const speedBar = `<div class=\"speed-bar\">${speedLayers.join('')}<span>${spdDisplay}</span></div>`;
      const successCount = Math.max(0, d.overtakeSuccess ?? 0);
      const failCount = Math.max(0, d.overtakeFail ?? 0);
      const totalCount = Math.max(0, d.overtakeTotal ?? (successCount + failCount));
      const engagementCell = `<span class="total">${totalCount}</span><span class="sep">/</span><span class="success">${successCount}</span><span class="sep">/</span><span class="fail">${failCount}</span>`;
      const rowClass = isFocus ? ' class="focus"' : '';
      const startSlot = Number.isFinite(d.startSlot) ? d.startSlot : idx;
      const displayRank = isGridPhase && Number.isFinite(d.startSlot) ? d.startSlot + 1 : idx + 1;
      let positionDisplay = `${displayRank}`;
      if (!isGridPhase) {
        const change = startSlot - idx;
        if (change > 0) {
          positionDisplay += ` <span class="pos-change up">‚Üë${change}</span>`;
        } else if (change < 0) {
          positionDisplay += ` <span class="pos-change down">‚Üì${Math.abs(change)}</span>`;
        }
      }
      return `<tr data-driver="${d.id}"${rowClass}><td>${positionDisplay}</td><td>${flag}${name}${teamLine}</td><td class="interval-cell">${gap}</td><td class="tyre-cell">${tyreCell}</td><td class="overtake-cell"><span class="engagement-stats">${engagementCell}</span></td><td class="speed-cell">${speedBar}</td><td class="lap-cell">${lapSummary}</td></tr>`;
    }).join('');
  }

  // ---- LOOP DRIVER ----
  function loop(t){
    if (!lastT) lastT = t;
    const dt = Math.min(0.1, (t - lastT) / 1000);
    lastT = t;
    if (started && !finished && !paused) step(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ---- UI ----
  const btnStart = document.getElementById('btnStart');
  const btnPauseResume = document.getElementById('btnPauseResume');
  const btnRestart = document.getElementById('btnRestart');

  btnStart.addEventListener('click', startRace);
  btnPauseResume.addEventListener('click', togglePauseResume);
  btnRestart.addEventListener('click', restartRace);

  document.addEventListener('keydown', (evt) => {
    if (evt.code === 'Space' || evt.key === ' ') {
      evt.preventDefault();
      if (!started && !finished) {
        startRace();
      } else if (started && !finished) {
        togglePauseResume();
      }
    }
  });

  function startRace() {
    if (started || finished) return;
    applyGridPositions(drivers);
    cameraState.targetId = drivers[0]?.id ?? cameraState.targetId ?? 0;
    started = true;
    paused = false;
    finished = false;
    simTime = 0;
    lastT = 0;
    acc = 0;
    fastestLapTime = Infinity;
    drivers.forEach(d=>{
      d.lapStartTime = 0;
      d.lastLapTime = null;
      d.bestLapTime = Infinity;
      d.lapTimes = [];
      d.finishTime = null;
      d.laneSmooth = 0;
      if (d.carStats) {
        d.carStats.tyreCondition = 1;
      }
      if (!Array.isArray(d.tyreInventory)) {
        d.tyreInventory = [];
      }
      if (Array.isArray(d.tyreHistory)) {
        d.tyreHistory.length = 1;
        d.tyreHistory[0] = d.carStats?.tyreCompound ?? (d.tyreHistory[0] ?? 'hard');
      } else {
        d.tyreHistory = [d.carStats?.tyreCompound ?? 'hard'];
      }
      d.inPit = false;
      d.pitTimer = 0;
      d.pitLapDisplay = 0;
      d.pitTargetCompound = null;
      d.lastPitService = null;
      d.pitJustExited = false;
      d.v = 0;
      d.overtakePenalty = 0;
      d.overtakeTimer = 0;
      d.overtakeTotal = 0;
      d.overtakeSuccess = 0;
      d.overtakeFail = 0;
      d.segmentType = segments[0]?.type || 'straight';
      d.segmentIndex = 0;
      d.drsActiveSegment = null;
      d.drsZoneId = null;
      d.drsGranted = false;
      d.drsEntryGap = null;
      d.overtakePenaltySource = null;
      d.isDNF = false;
      d.overtakeBoostAccel = 0;
      d.overtakeBoostTop = 0;
      d.overtakeBoostTimer = 0;
      d.intervalDisplay = '‚Äî';
      d.throttle = 0;
      d.brake = 0;
      d.pedalPlan = null;
      d.activeApex = null;
      d.missedApex = 0;
      d.lookaheadTimer = 0;
      d.targetThrottle = 1;
      d.targetBrakeIntent = 0;
      d.brakingForApex = false;
      d.brakePrediction = null;
    });
    if (drivers.length) drivers[0].intervalDisplay = '+0.0 s';
    resetSpeedGraph(drivers[0] ?? null);
    sampleSpeedGraph(drivers[0] ?? null, { force: true });
    renderSpeedGraph();
    updateControls();
    updateStatus();
  }

  function pauseRace() {
    if (!started || finished || paused) return;
    paused = true;
    updateControls();
    updateStatus();
  }

  function resumeRace() {
    if (!started || finished || !paused) return;
    paused = false;
    lastT = 0;
    updateControls();
    updateStatus();
  }

  function togglePauseResume() {
    if (!started || finished) return;
    if (paused) resumeRace(); else pauseRace();
  }

  function restartRace() {
    drivers = createDriversForMode(sessionMode);
    applyLookaheadScaleToDrivers(drivers);
    applyGridPositions(drivers);
    cameraState.targetId = drivers[0]?.id ?? cameraState.targetId ?? 0;
    resetSpeedGraph(drivers[0] ?? null);
    sampleSpeedGraph(drivers[0] ?? null, { force: true });
    renderSpeedGraph();
    fastestLapTime = Infinity;
    started = false;
    finished = false;
    paused = false;
    simTime = 0;
    lastT = 0;
    acc = 0;
    isHoveringSegment = false;
    segmentState = { source:'', index:-1, lap:null };
    updateSegmentInfoForPlayer();
    updateControls();
    updateStatus();
    if (drivers.length) drivers[0].intervalDisplay = '+0.0 s';
  }

  function setSessionMode(nextMode) {
    const normalized = nextMode === 'race' ? 'race' : 'practice';
    if (normalized === sessionMode) return;
    sessionMode = normalized;
    if (sessionModeSel && sessionModeSel.value !== normalized) {
      sessionModeSel.value = normalized;
    }
    restartRace();
  }

  function updateControls() {
    btnStart.disabled = started || finished;
    btnPauseResume.disabled = !started || finished;
    btnPauseResume.textContent = paused ? 'Resume' : 'Pause';
    btnRestart.disabled = !started && simTime === 0 && !finished;
  }

  // ---- helpers ----
  function applyOvertakePenalty(driver, effect) {
    if (!driver || !effect) return;
    const strength = clamp(effect.strength ?? 0, 0, 0.9);
    const duration = Math.max(0, effect.duration ?? 0);
    if (strength <= 0 || duration <= 0) return;
    driver.overtakePenalty = Math.max(driver.overtakePenalty ?? 0, strength);
    driver.overtakeTimer = Math.max(driver.overtakeTimer ?? 0, duration);
  }
  function applyOvertakeBoost(driver, accelBoost, topBoost, duration) {
    if (!driver || duration <= 0) return;
    driver.overtakeBoostAccel = Math.max(driver.overtakeBoostAccel ?? 0, accelBoost ?? 0);
    driver.overtakeBoostTop = Math.max(driver.overtakeBoostTop ?? 0, topBoost ?? 0);
    driver.overtakeBoostTimer = Math.max(driver.overtakeBoostTimer ?? 0, duration);
  }
  function setDNF(driver, finishTime) {
    if (!driver || driver.finished) return;
    driver.finished = true;
    driver.finishTime = finishTime;
    driver.v = 0;
    driver.isDNF = true;
    driver.intervalDisplay = '<span style="color:#bd93f9;font-weight:600">DNF</span>';
  }
  function applyTeamModifiers(car, team) {
    const mod = teamCarModifiers[team];
    if (!mod) return;
    if (mod.top) {
      car.topSpeed = clamp(car.topSpeed * mod.top, 320, 370);
    }
    if (mod.accel) {
      car.baseAccel = clamp01(car.baseAccel * mod.accel);
      car.accel = clamp01(car.accel * mod.accel);
    }
    if (mod.handling) {
      car.baseHandling = clamp01(car.baseHandling * mod.handling);
      car.handling = clamp01(car.handling * mod.handling);
    }
  }
function clamp(x,min=0,max=1){ return Math.max(min, Math.min(max, x)); }
function lerp(a,b,t){ return a + (b - a) * t; }
function clamp01(x){ return clamp(x,0,1); }
function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
updateControls();
updateStatus();
})();
</script>
</body>
</html>
